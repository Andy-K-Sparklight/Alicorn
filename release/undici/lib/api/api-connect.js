"use strict";const{InvalidArgumentError,RequestAbortedError,SocketError}=require("../core/errors"),{AsyncResource}=require("async_hooks"),util=require("../core/util"),{addSignal,removeSignal}=require("./abort-signal");class ConnectHandler extends AsyncResource{constructor(e,t){if(!e||"object"!=typeof e)throw new InvalidArgumentError("invalid opts");if("function"!=typeof t)throw new InvalidArgumentError("invalid callback");const{signal:r,opaque:n}=e;if(r&&"function"!=typeof r.on&&"function"!=typeof r.addEventListener)throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");super("UNDICI_CONNECT"),this.opaque=n||null,this.callback=t,this.abort=null,addSignal(this,r)}onConnect(e,t){if(!this.callback)throw new RequestAbortedError;this.abort=e,this.context=t}onHeaders(){throw new SocketError("bad connect",null)}onUpgrade(e,t,r){const{callback:n,opaque:o,context:c}=this;removeSignal(this),this.callback=null,this.runInAsyncScope(n,null,null,{statusCode:e,headers:util.parseHeaders(t),socket:r,opaque:o,context:c})}onError(e){const{callback:t,opaque:r}=this;removeSignal(this),t&&(this.callback=null,queueMicrotask((()=>{this.runInAsyncScope(t,null,e,{opaque:r})})))}}function connect(e,t){if(void 0===t)return new Promise(((t,r)=>{connect.call(this,e,((e,n)=>e?r(e):t(n)))}));try{const r=new ConnectHandler(e,t);this.dispatch({...e,method:"CONNECT"},r)}catch(r){if("function"!=typeof t)throw r;const n=e&&e.opaque;queueMicrotask((()=>t(r,{opaque:n})))}}module.exports=connect;
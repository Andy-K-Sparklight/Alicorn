"use strict";const{Readable,Duplex,PassThrough}=require("stream"),{InvalidArgumentError,InvalidReturnValueError,RequestAbortedError}=require("../core/errors"),util=require("../core/util"),{AsyncResource}=require("async_hooks"),{addSignal,removeSignal}=require("./abort-signal"),assert=require("assert"),kResume=Symbol("resume");class PipelineRequest extends Readable{constructor(){super({autoDestroy:!0}),this[kResume]=null}_read(){const{[kResume]:e}=this;e&&(this[kResume]=null,e())}_destroy(e,t){this._read(),t(e)}}class PipelineResponse extends Readable{constructor(e){super({autoDestroy:!0}),this[kResume]=e}_read(){this[kResume]()}_destroy(e,t){e||this._readableState.endEmitted||(e=new RequestAbortedError),t(e)}}class PipelineHandler extends AsyncResource{constructor(e,t){if(!e||"object"!=typeof e)throw new InvalidArgumentError("invalid opts");if("function"!=typeof t)throw new InvalidArgumentError("invalid handler");const{signal:r,method:s,opaque:n,onInfo:o}=e;if(r&&"function"!=typeof r.on&&"function"!=typeof r.addEventListener)throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");if("CONNECT"===s)throw new InvalidArgumentError("invalid method");if(o&&"function"!=typeof o)throw new InvalidArgumentError("invalid onInfo callback");super("UNDICI_PIPELINE"),this.opaque=n||null,this.handler=t,this.abort=null,this.context=null,this.onInfo=o||null,this.req=(new PipelineRequest).on("error",util.nop),this.ret=new Duplex({readableObjectMode:e.objectMode,autoDestroy:!0,read:()=>{const{body:e}=this;e&&e.resume&&e.resume()},write:(e,t,r)=>{const{req:s}=this;s.push(e,t)||s._readableState.destroyed?r():s[kResume]=r},destroy:(e,t)=>{const{body:r,req:s,res:n,ret:o,abort:i}=this;e||o._readableState.endEmitted||(e=new RequestAbortedError),i&&e&&i(),util.destroy(r,e),util.destroy(s,e),util.destroy(n,e),removeSignal(this),t(e)}}).on("prefinish",(()=>{const{req:e}=this;e.push(null)})),this.res=null,addSignal(this,r)}onConnect(e,t){const{ret:r,res:s}=this;if(assert(!s,"pipeline cannot be retried"),r.destroyed)throw new RequestAbortedError;this.abort=e,this.context=t}onHeaders(e,t,r){const{opaque:s,handler:n,context:o}=this;if(e<200)return void(this.onInfo&&this.onInfo({statusCode:e,headers:util.parseHeaders(t)}));let i;this.res=new PipelineResponse(r);try{this.handler=null,i=this.runInAsyncScope(n,null,{statusCode:e,headers:util.parseHeaders(t),opaque:s,body:this.res,context:o})}catch(e){throw this.res.on("error",util.nop),e}if(!i||"function"!=typeof i.on)throw new InvalidReturnValueError("expected Readable");i.on("data",(e=>{const{ret:t,body:r}=this;!t.push(e)&&r.pause&&r.pause()})).on("error",(e=>{const{ret:t}=this;util.destroy(t,e)})).on("end",(()=>{const{ret:e}=this;e.push(null)})).on("close",(()=>{const{ret:e}=this;e._readableState.ended||util.destroy(e,new RequestAbortedError)})),this.body=i}onData(e){const{res:t}=this;return t.push(e)}onComplete(e){const{res:t}=this;t.push(null)}onError(e){const{ret:t}=this;this.handler=null,util.destroy(t,e)}}function pipeline(e,t){try{const r=new PipelineHandler(e,t);return this.dispatch({...e,body:r.req},r),r.ret}catch(e){return(new PassThrough).destroy(e)}}module.exports=pipeline;
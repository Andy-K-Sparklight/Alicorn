"use strict";const assert=require("assert"),{Readable}=require("stream"),{RequestAbortedError,NotSupportedError}=require("../core/errors"),util=require("../core/util"),{ReadableStreamFrom,toUSVString}=require("../core/util");let Blob;const kConsume=Symbol("kConsume"),kReading=Symbol("kReading"),kBody=Symbol("kBody"),kAbort=Symbol("abort"),kContentType=Symbol("kContentType");function isLocked(e){return e[kBody]&&!0===e[kBody].locked||e[kConsume]}function isUnusable(e){return util.isDisturbed(e)||isLocked(e)}async function consume(e,t){if(isUnusable(e))throw new TypeError("unusable");return assert(!e[kConsume]),new Promise(((r,o)=>{e[kConsume]={type:t,stream:e,resolve:r,reject:o,length:0,body:[]},e.on("error",(function(e){consumeFinish(this[kConsume],e)})).on("close",(function(){null!==this[kConsume].body&&consumeFinish(this[kConsume],new RequestAbortedError)})),process.nextTick(consumeStart,e[kConsume])}))}function consumeStart(e){if(null===e.body)return;const{_readableState:t}=e.stream;for(const r of t.buffer)consumePush(e,r);for(t.endEmitted?consumeEnd(this[kConsume]):e.stream.on("end",(function(){consumeEnd(this[kConsume])})),e.stream.resume();null!=e.stream.read(););}function consumeEnd(e){const{type:t,body:r,resolve:o,stream:s,length:n}=e;try{if("text"===t)o(r.join(""));else if("json"===t)o(JSON.parse(r.join("")));else if("arrayBuffer"===t){const e=new Uint8Array(n);let t=0;for(const o of r)e.set(o,t),t+=o.byteLength;o(e)}else"blob"===t&&(Blob||(Blob=require("buffer").Blob),o(new Blob(r,{type:s[kContentType]})));consumeFinish(e)}catch(e){s.destroy(e)}}function consumePush(e,t){e.length+=t.length,e.body.push(t)}function consumeFinish(e,t){null!==e.body&&(t?e.reject(t):e.resolve(),e.reject=null,e.resolve=null,e.decoder=null,e.body=null)}module.exports=class extends Readable{constructor(e,t,r=""){super({autoDestroy:!0,read:e,highWaterMark:65536}),this._readableState.dataEmitted=!1,this[kAbort]=t,this[kConsume]=null,this[kBody]=null,this[kContentType]=r,this[kReading]=!1}destroy(e){return this.destroyed?this:(e||this._readableState.endEmitted||(e=new RequestAbortedError),e&&this[kAbort](),super.destroy(e))}emit(e,...t){return"data"===e?this._readableState.dataEmitted=!0:"error"===e&&(this._readableState.errorEmitted=!0),super.emit(e,...t)}on(e,...t){return"data"!==e&&"readable"!==e||(this[kReading]=!0),super.on(e,...t)}addListener(e,...t){return this.on(e,...t)}off(e,...t){const r=super.off(e,...t);return"data"!==e&&"readable"!==e||(this[kReading]=this.listenerCount("data")>0||this.listenerCount("readable")>0),r}removeListener(e,...t){return this.off(e,...t)}push(e){return this[kConsume]&&null!==e&&!this[kReading]?(consumePush(this[kConsume],e),!0):super.push(e)}async text(){return toUSVString(await consume(this,"text"))}async json(){return consume(this,"json")}async blob(){return consume(this,"blob")}async arrayBuffer(){return consume(this,"arrayBuffer")}async formData(){throw new NotSupportedError}get bodyUsed(){return util.isDisturbed(this)}get body(){return this[kBody]||(this[kBody]=ReadableStreamFrom(this),this[kConsume]&&(this[kBody].getReader(),assert(this[kBody].locked))),this[kBody]}};
"use strict";const{InvalidArgumentError,RequestAbortedError,SocketError}=require("../core/errors"),{AsyncResource}=require("async_hooks"),util=require("../core/util"),{addSignal,removeSignal}=require("./abort-signal"),assert=require("assert");class UpgradeHandler extends AsyncResource{constructor(e,r){if(!e||"object"!=typeof e)throw new InvalidArgumentError("invalid opts");if("function"!=typeof r)throw new InvalidArgumentError("invalid callback");const{signal:t,opaque:o}=e;if(t&&"function"!=typeof t.on&&"function"!=typeof t.addEventListener)throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");super("UNDICI_UPGRADE"),this.opaque=o||null,this.callback=r,this.abort=null,this.context=null,addSignal(this,t)}onConnect(e,r){if(!this.callback)throw new RequestAbortedError;this.abort=e,this.context=null}onHeaders(){throw new SocketError("bad upgrade",null)}onUpgrade(e,r,t){const{callback:o,opaque:n,context:a}=this;assert.strictEqual(e,101),removeSignal(this),this.callback=null,this.runInAsyncScope(o,null,null,{headers:util.parseHeaders(r),socket:t,opaque:n,context:a})}onError(e){const{callback:r,opaque:t}=this;removeSignal(this),r&&(this.callback=null,queueMicrotask((()=>{this.runInAsyncScope(r,null,e,{opaque:t})})))}}function upgrade(e,r){if(void 0===r)return new Promise(((r,t)=>{upgrade.call(this,e,((e,o)=>e?t(e):r(o)))}));try{const t=new UpgradeHandler(e,r);this.dispatch({...e,method:e.method||"GET",upgrade:e.protocol||"Websocket"},t)}catch(t){if("function"!=typeof r)throw t;const o=e&&e.opaque;queueMicrotask((()=>r(t,{opaque:o})))}}module.exports=upgrade;
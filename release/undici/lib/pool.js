"use strict";const Dispatcher=require("./dispatcher"),Client=require("./client"),{ClientClosedError,InvalidArgumentError,ClientDestroyedError}=require("./core/errors"),FixedQueue=require("./node/fixed-queue"),util=require("./core/util"),{kSize,kRunning,kUrl,kPending,kBusy}=require("./core/symbols"),assert=require("assert"),buildConnector=require("./core/connect"),kClients=Symbol("clients"),kNeedDrain=Symbol("needDrain"),kQueue=Symbol("queue"),kDestroyed=Symbol("destroyed"),kClosedPromise=Symbol("closed promise"),kClosedResolve=Symbol("closed resolve"),kOptions=Symbol("options"),kOnDrain=Symbol("onDrain"),kOnConnect=Symbol("onConnect"),kOnDisconnect=Symbol("onDisconnect"),kOnConnectionError=Symbol("onConnectionError"),kConnections=Symbol("connections"),kFactory=Symbol("factory"),kQueued=Symbol("queued");function defaultFactory(e,n){return new Client(e,n)}class Pool extends Dispatcher{constructor(e,{connections:n,factory:t=defaultFactory,connect:o,connectTimeout:i,tls:r,maxCachedSessions:s,socketPath:l,...c}={}){if(super(),null!=n&&(!Number.isFinite(n)||n<0))throw new InvalidArgumentError("invalid connections");if("function"!=typeof t)throw new InvalidArgumentError("factory must be a function.");if(null!=o&&"function"!=typeof o&&"object"!=typeof o)throw new InvalidArgumentError("connect must be a function or an object");"function"!=typeof o&&(o=buildConnector({...r,maxCachedSessions:s,socketPath:l,timeout:null==i?1e4:i,...o})),this[kConnections]=n||null,this[kUrl]=util.parseOrigin(e),this[kOptions]={...util.deepClone(c),connect:o},this[kQueue]=new FixedQueue,this[kClosedPromise]=null,this[kClosedResolve]=null,this[kDestroyed]=!1,this[kClients]=[],this[kNeedDrain]=!1,this[kQueued]=0,this[kFactory]=t;const u=this;this[kOnDrain]=function(n,t){assert(u[kUrl].origin===n.origin);const o=u[kQueue];let i=!1;for(;!i;){const e=o.shift();if(!e)break;u[kQueued]--,i=!this.dispatch(e.opts,e.handler)}this[kNeedDrain]=i,!this[kNeedDrain]&&u[kNeedDrain]&&(u[kNeedDrain]=!1,u.emit("drain",e,[u,...t])),u[kClosedResolve]&&o.isEmpty()&&Promise.all(u[kClients].map((e=>e.close()))).then(u[kClosedResolve])},this[kOnConnect]=(e,n)=>{u.emit("connect",e,[u,...n])},this[kOnDisconnect]=(e,n,t)=>{u.emit("disconnect",e,[u,...n],t)},this[kOnConnectionError]=(e,n,t)=>{u.emit("connectionError",e,[u,...n],t)}}get[kBusy](){return this[kNeedDrain]}get[kPending](){let e=this[kQueued];for(const{[kPending]:n}of this[kClients])e+=n;return e}get[kRunning](){let e=0;for(const{[kRunning]:n}of this[kClients])e+=n;return e}get[kSize](){let e=this[kQueued];for(const{[kSize]:n}of this[kClients])e+=n;return e}get destroyed(){return this[kDestroyed]}get closed(){return null!=this[kClosedPromise]}dispatch(e,n){if(!n||"object"!=typeof n)throw new InvalidArgumentError("handler must be an object");try{if(this[kDestroyed])throw new ClientDestroyedError;if(this[kClosedPromise])throw new ClientClosedError;let t=this[kClients].find((e=>!e[kNeedDrain]));t||(!this[kConnections]||this[kClients].length<this[kConnections])&&(t=this[kFactory](this[kUrl],this[kOptions]).on("drain",this[kOnDrain]).on("connect",this[kOnConnect]).on("disconnect",this[kOnDisconnect]).on("connectionError",this[kOnConnectionError]),this[kClients].push(t)),t?t.dispatch(e,n)||(t[kNeedDrain]=!0,this[kNeedDrain]=this[kConnections]&&this[kClients].length===this[kConnections]):(this[kNeedDrain]=!0,this[kQueue].push({opts:e,handler:n}),this[kQueued]++)}catch(e){if("function"!=typeof n.onError)throw new InvalidArgumentError("invalid onError method");n.onError(e)}return!this[kNeedDrain]}close(e){try{if(this[kDestroyed])throw new ClientDestroyedError;if(this[kClosedPromise]||(this[kQueue].isEmpty()?this[kClosedPromise]=Promise.all(this[kClients].map((e=>e.close()))):this[kClosedPromise]=new Promise((e=>{this[kClosedResolve]=e})),this[kClosedPromise]=this[kClosedPromise].then((()=>{this[kDestroyed]=!0}))),!e)return this[kClosedPromise];this[kClosedPromise].then((()=>e(null,null)))}catch(n){if(!e)return Promise.reject(n);e(n)}}destroy(e,n){for(this[kDestroyed]=!0,"function"==typeof e&&(n=e,e=null),e||(e=new ClientDestroyedError);;){const n=this[kQueue].shift();if(!n)break;n.handler.onError(e)}const t=Promise.all(this[kClients].map((n=>n.destroy(e))));if(!n)return t;t.then((()=>n(null,null)))}}module.exports=Pool;
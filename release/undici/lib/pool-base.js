"use strict";const Dispatcher=require("./dispatcher"),{ClientDestroyedError,ClientClosedError,InvalidArgumentError}=require("./core/errors"),FixedQueue=require("./node/fixed-queue"),{kSize,kRunning,kPending,kBusy}=require("./core/symbols"),kClients=Symbol("clients"),kNeedDrain=Symbol("needDrain"),kQueue=Symbol("queue"),kDestroyed=Symbol("destroyed"),kClosedPromise=Symbol("closed promise"),kClosedResolve=Symbol("closed resolve"),kOnDrain=Symbol("onDrain"),kOnConnect=Symbol("onConnect"),kOnDisconnect=Symbol("onDisconnect"),kOnConnectionError=Symbol("onConnectionError"),kQueued=Symbol("queued"),kDispatch=Symbol("dispatch"),kAddClient=Symbol("add client"),kRemoveClient=Symbol("remove client");class PoolBase extends Dispatcher{constructor(){super(),this[kQueue]=new FixedQueue,this[kClosedPromise]=null,this[kClosedResolve]=null,this[kDestroyed]=!1,this[kClients]=[],this[kNeedDrain]=!1,this[kQueued]=0;const e=this;this[kOnDrain]=function(t,n){const i=e[kQueue];let s=!1;for(;!s;){const t=i.shift();if(!t)break;e[kQueued]--,s=!this.dispatch(t.opts,t.handler)}this[kNeedDrain]=s,!this[kNeedDrain]&&e[kNeedDrain]&&(e[kNeedDrain]=!1,e.emit("drain",t,[e,...n])),e[kClosedResolve]&&i.isEmpty()&&Promise.all(e[kClients].map((e=>e.close()))).then(e[kClosedResolve])},this[kOnConnect]=(t,n)=>{e.emit("connect",t,[e,...n])},this[kOnDisconnect]=(t,n,i)=>{e.emit("disconnect",t,[e,...n],i)},this[kOnConnectionError]=(t,n,i)=>{e.emit("connectionError",t,[e,...n],i)}}get[kBusy](){return this[kNeedDrain]}get[kPending](){let e=this[kQueued];for(const{[kPending]:t}of this[kClients])e+=t;return e}get[kRunning](){let e=0;for(const{[kRunning]:t}of this[kClients])e+=t;return e}get[kSize](){let e=this[kQueued];for(const{[kSize]:t}of this[kClients])e+=t;return e}get destroyed(){return this[kDestroyed]}get closed(){return null!=this[kClosedPromise]}close(e){try{if(this[kDestroyed])throw new ClientDestroyedError;if(this[kClosedPromise]||(this[kQueue].isEmpty()?this[kClosedPromise]=Promise.all(this[kClients].map((e=>e.close()))):this[kClosedPromise]=new Promise((e=>{this[kClosedResolve]=e})),this[kClosedPromise]=this[kClosedPromise].then((()=>{this[kDestroyed]=!0}))),!e)return this[kClosedPromise];this[kClosedPromise].then((()=>e(null,null)))}catch(t){if(!e)return Promise.reject(t);e(t)}}destroy(e,t){for(this[kDestroyed]=!0,"function"==typeof e&&(t=e,e=null),e||(e=new ClientDestroyedError);;){const t=this[kQueue].shift();if(!t)break;t.handler.onError(e)}const n=Promise.all(this[kClients].map((t=>t.destroy(e))));if(!t)return n;n.then((()=>t(null,null)))}dispatch(e,t){if(!t||"object"!=typeof t)throw new InvalidArgumentError("handler must be an object");try{if(this[kDestroyed])throw new ClientDestroyedError;if(this[kClosedPromise])throw new ClientClosedError;const n=this[kDispatch]();n?n.dispatch(e,t)||(n[kNeedDrain]=!0,this[kNeedDrain]=this[kClients].some((e=>!e[kNeedDrain]&&!0!==e.closed&&!0!==e.destroyed))):(this[kNeedDrain]=!0,this[kQueue].push({opts:e,handler:t}),this[kQueued]++)}catch(e){if("function"!=typeof t.onError)throw new InvalidArgumentError("invalid onError method");t.onError(e)}return!this[kNeedDrain]}[kAddClient](e){return e.on("drain",this[kOnDrain]).on("connect",this[kOnConnect]).on("disconnect",this[kOnDisconnect]).on("connectionError",this[kOnConnectionError]),this[kClients].push(e),this[kNeedDrain]&&process.nextTick((()=>{this[kNeedDrain]&&this[kOnDrain](e[kUrl],[this,e])})),this}[kRemoveClient](e){e.close((()=>{const t=this[kClients].indexOf(e);-1!==t&&this[kClients].splice(t,1)})),this[kNeedDrain]=this[kClients].some((e=>!e[kNeedDrain]&&!0!==e.closed&&!0!==e.destroyed))}}module.exports={PoolBase,kClients,kNeedDrain,kAddClient,kRemoveClient,kDispatch};
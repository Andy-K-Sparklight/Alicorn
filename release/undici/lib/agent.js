"use strict";const{ClientClosedError,InvalidArgumentError,ClientDestroyedError}=require("./core/errors"),{kClients,kRunning}=require("./core/symbols"),Dispatcher=require("./dispatcher"),Pool=require("./pool"),Client=require("./client"),util=require("./core/util"),RedirectHandler=require("./handler/redirect"),{WeakRef,FinalizationRegistry}=require("./compat/dispatcher-weakref")(),kDestroyed=Symbol("destroyed"),kClosed=Symbol("closed"),kOnConnect=Symbol("onConnect"),kOnDisconnect=Symbol("onDisconnect"),kOnConnectionError=Symbol("onConnectionError"),kMaxRedirections=Symbol("maxRedirections"),kOnDrain=Symbol("onDrain"),kFactory=Symbol("factory"),kFinalizer=Symbol("finalizer"),kOptions=Symbol("options");function defaultFactory(e,n){return n&&1===n.connections?new Client(e,n):new Pool(e,n)}class Agent extends Dispatcher{constructor({factory:e=defaultFactory,maxRedirections:n=0,connect:t,...r}={}){if(super(),"function"!=typeof e)throw new InvalidArgumentError("factory must be a function.");if(null!=t&&"function"!=typeof t&&"object"!=typeof t)throw new InvalidArgumentError("connect must be a function or an object");if(!Number.isInteger(n)||n<0)throw new InvalidArgumentError("maxRedirections must be a positive number");t&&"function"!=typeof t&&(t={...t}),this[kOptions]={...util.deepClone(r),connect:t},this[kMaxRedirections]=n,this[kFactory]=e,this[kClients]=new Map,this[kFinalizer]=new FinalizationRegistry((e=>{const n=this[kClients].get(e);void 0!==n&&void 0===n.deref()&&this[kClients].delete(e)})),this[kClosed]=!1,this[kDestroyed]=!1;const o=this;this[kOnDrain]=(e,n)=>{o.emit("drain",e,[o,...n])},this[kOnConnect]=(e,n)=>{o.emit("connect",e,[o,...n])},this[kOnDisconnect]=(e,n,t)=>{o.emit("disconnect",e,[o,...n],t)},this[kOnConnectionError]=(e,n,t)=>{o.emit("connectionError",e,[o,...n],t)}}get[kRunning](){let e=0;for(const n of this[kClients].values()){const t=n.deref();t&&(e+=t[kRunning])}return e}dispatch(e,n){if(!n||"object"!=typeof n)throw new InvalidArgumentError("handler must be an object.");try{if(!e||"object"!=typeof e)throw new InvalidArgumentError("opts must be an object.");let t;if(!e.origin||!("string"==typeof e.origin||e.origin instanceof URL))throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");if(t=String(e.origin),this[kDestroyed])throw new ClientDestroyedError;if(this[kClosed])throw new ClientClosedError;const r=this[kClients].get(t);let o=r?r.deref():null;o||(o=this[kFactory](e.origin,this[kOptions]).on("drain",this[kOnDrain]).on("connect",this[kOnConnect]).on("disconnect",this[kOnDisconnect]).on("connectionError",this[kOnConnectionError]),this[kClients].set(t,new WeakRef(o)),this[kFinalizer].register(o,t));const{maxRedirections:i=this[kMaxRedirections]}=e;return null!=i&&0!==i&&(e={...e,maxRedirections:0},n=new RedirectHandler(this,i,e,n)),o.dispatch(e,n)}catch(e){if("function"!=typeof n.onError)throw new InvalidArgumentError("invalid onError method");n.onError(e)}}get closed(){return this[kClosed]}get destroyed(){return this[kDestroyed]}close(e){if(null!=e&&"function"!=typeof e)throw new InvalidArgumentError("callback must be a function");this[kClosed]=!0;const n=[];for(const e of this[kClients].values()){const t=e.deref();t&&n.push(t.close())}if(!e)return Promise.all(n);Promise.all(n).then((()=>process.nextTick(e)))}destroy(e,n){if("function"==typeof e&&(n=e,e=null),null!=n&&"function"!=typeof n)throw new InvalidArgumentError("callback must be a function");this[kClosed]=!0,this[kDestroyed]=!0;const t=[];for(const n of this[kClients].values()){const r=n.deref();r&&t.push(r.destroy(e))}if(!n)return Promise.all(t);Promise.all(t).then((()=>process.nextTick(n)))}}module.exports=Agent;
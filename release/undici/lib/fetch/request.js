"use strict";const{extractBody,mixinBody,cloneBody}=require("./body"),{Headers,fill:fillHeaders,HeadersList}=require("./headers"),util=require("../core/util"),{isValidHTTPToken,EnvironmentSettingsObject,toUSVString}=require("./util"),{forbiddenMethods,corsSafeListedMethods,referrerPolicy,requestRedirect,requestMode,requestCredentials,requestCache}=require("./constants"),{kEnumerableProperty}=util,{kHeaders,kSignal,kState,kGuard,kRealm}=require("./symbols"),{kHeadersList}=require("../core/symbols"),assert=require("assert");let TransformStream;const kInit=Symbol("init");class Request{constructor(...e){if(e[0]===kInit)return;if(e.length<1)throw new TypeError(`Failed to construct 'Request': 1 argument required, but only ${e.length} present.`);if(e.length>=1&&"object"!=typeof e[1]&&void 0!==e[1])throw new TypeError("Failed to construct 'Request': cannot convert to dictionary.");const t=e[0]instanceof Request?e[0]:toUSVString(e[0]),r=e.length>=1?e[1]??{}:{};this[kRealm]={settingsObject:{}};let i=null,o=null;const n=this[kRealm].settingsObject.baseUrl;let s=null;if("string"==typeof t){let e;try{e=new URL(t,n)}catch(e){const r=new TypeError("Failed to parse URL from "+t);throw r.cause=e,r}if(e.username||e.password)throw new TypeError("Request cannot be constructed from a URL that includes credentials: "+t);i=makeRequest({urlList:[e]}),o="cors"}else assert(t instanceof Request),i=t[kState],s=t[kSignal];const a=this[kRealm].settingsObject.origin;let l,d="client";if(i.window instanceof EnvironmentSettingsObject&&i.window.origin===a&&(d=i.window),"window"in r&&null!==d)throw new TypeError(`'window' option '${d}' must be null`);if("window"in r&&(d="no-window"),i=makeRequest({...i,window:d}),Object.keys(r).length>0&&("navigate"===i.mode&&(i.mode="same-origin"),i.reloadNavigation=!1,i.historyNavigation=!1,i.referrer="client",i.referrerPolicy=""),"referrer"in r){const e=r.referrer;if(""===!e)i.referrer="no-referrer";else{let t;try{t=new URL(e,n)}catch(t){const r=new TypeError(`Referrer "${e}" is not a valid URL.`);throw r.cause=t,r}i.referrer=t}}if("referrerPolicy"in r&&(i.referrerPolicy=r.referrerPolicy,!referrerPolicy.includes(i.referrerPolicy)))throw new TypeError(`Failed to construct 'Request': The provided value '${i.referrerPolicy}' is not a valid enum value of type ReferrerPolicy.`);if("mode"in r){if(l=r.mode,!requestMode.includes(l))throw new TypeError(`Failed to construct 'Request': The provided value '${i.mode}' is not a valid enum value of type RequestMode.`)}else l=o;if("navigate"===l)throw new TypeError;if(null!==l&&(i.mode=l),"credentials"in r&&(i.credentials=r.credentials,!requestCredentials.includes(i.credentials)))throw new TypeError(`Failed to construct 'Request': The provided value '${i.credentials}' is not a valid enum value of type RequestCredentials.`);if("cache"in r&&(i.cache=r.cache,!requestCache.includes(i.cache)))throw new TypeError(`Failed to construct 'Request': The provided value '${i.cache}' is not a valid enum value of type RequestCache.`);if("only-if-cached"===i.cache&&"same-origin"!==i.mode)throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");if("redirect"in r&&(i.redirect=r.redirect,!requestRedirect.includes(i.redirect)))throw new TypeError(`Failed to construct 'Request': The provided value '${i.redirect}' is not a valid enum value of type RequestRedirect.`);if("integrity"in r&&(i.integrity=String(r.integrity)),"keepalive"in r&&(i.keepalive=Boolean(r.keepalive)),"method"in r){let e=r.method;if(!isValidHTTPToken(r.method))throw TypeError(`'${r.method}' is not a valid HTTP method.`);if(-1!==forbiddenMethods.indexOf(e.toUpperCase()))throw TypeError(`'${r.method}' HTTP method is unsupported.`);e=r.method.toUpperCase(),i.method=e}"signal"in r&&(s=r.signal),this[kState]=i;const c=new AbortController;if(this[kSignal]=c.signal,this[kSignal][kRealm]=this[kRealm],null!=s){if(!s||"boolean"!=typeof s.aborted||"function"!=typeof s.addEventListener)throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");s.aborted?c.abort():s.addEventListener("abort",(function(){c.abort()}),{once:!0})}if(this[kHeaders]=new Headers,this[kHeaders][kGuard]="request",this[kHeaders][kHeadersList]=i.headersList,this[kHeaders][kRealm]=this[kRealm],"no-cors"===l){if(!corsSafeListedMethods.includes(i.method))throw new TypeError(`'${i.method} is unsupported in no-cors mode.`);this[kHeaders][kGuard]="request-no-cors"}if(0!==Object.keys(r).length){let e=new Headers(this.headers);"headers"in r&&(e=r.headers),this[kState].headersList=new HeadersList,this[kHeaders][kHeadersList]=this[kState].headersList,e instanceof Headers?this[kState].headersList.push(...e[kHeadersList]):fillHeaders(this[kState].headersList,e)}const u=t instanceof Request?t[kState].body:null;if(("body"in r&&null!=r.body||null!=u)&&("GET"===i.method||"HEAD"===i.method))throw new TypeError("Request with GET/HEAD method cannot have body.");let h=null;if("body"in r&&null!=r.body){const[e,t]=extractBody(r.body,i.keepalive);h=e,t&&!this[kHeaders].has("content-type")&&this[kHeaders].append("content-type",t)}const f=h??u;if(null!=f&&null==f.source){if("same-origin"!==i.mode&&"cors"!==i.mode)throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');i.useCORSPreflightFlag=!0}let y=f;if(null==h&&null!=u){if(util.isDisturbed(u.stream)||u.stream.locked)throw new TypeError("Cannot construct a Request with a Request object that has already been used.");TransformStream||(TransformStream=require("stream/web").TransformStream);const e=new TransformStream;u.stream.pipeThrough(e),y={source:u.source,length:u.length,stream:e.readable}}this[kState].body=y}get[Symbol.toStringTag](){if(!(this instanceof Request))throw new TypeError("Illegal invocation");return this.constructor.name}get method(){if(!(this instanceof Request))throw new TypeError("Illegal invocation");return this[kState].method}get url(){if(!(this instanceof Request))throw new TypeError("Illegal invocation");return this[kState].url.toString()}get headers(){if(!(this instanceof Request))throw new TypeError("Illegal invocation");return this[kHeaders]}get destination(){if(!(this instanceof Request))throw new TypeError("Illegal invocation");return this[kState].destination}get referrer(){if(!(this instanceof Request))throw new TypeError("Illegal invocation");return"no-referrer"===this[kState].referrer?"":"client"===this[kState].referrer?"about:client":this[kState].referrer.toString()}get referrerPolicy(){if(!(this instanceof Request))throw new TypeError("Illegal invocation");return this[kState].referrerPolicy}get mode(){if(!(this instanceof Request))throw new TypeError("Illegal invocation");return this[kState].mode}get credentials(){return this[kState].credentials}get cache(){if(!(this instanceof Request))throw new TypeError("Illegal invocation");return this[kState].cache}get redirect(){if(!(this instanceof Request))throw new TypeError("Illegal invocation");return this[kState].redirect}get integrity(){if(!(this instanceof Request))throw new TypeError("Illegal invocation");return this[kState].integrity}get keepalive(){if(!(this instanceof Request))throw new TypeError("Illegal invocation");return this[kState].keepalive}get isReloadNavigation(){if(!(this instanceof Request))throw new TypeError("Illegal invocation");return this[kState].reloadNavigation}get isHistoryNavigation(){if(!(this instanceof Request))throw new TypeError("Illegal invocation");return this[kState].historyNavigation}get signal(){if(!(this instanceof Request))throw new TypeError("Illegal invocation");return this[kSignal]}clone(){if(!(this instanceof Request))throw new TypeError("Illegal invocation");if(this.bodyUsed||this.body&&this.body.locked)throw new TypeError("unusable");const e=cloneRequest(this[kState]),t=new Request(kInit);t[kState]=e,t[kRealm]=this[kRealm],t[kHeaders]=new Headers,t[kHeaders][kHeadersList]=e.headersList,t[kHeaders][kGuard]=this[kHeaders][kGuard],t[kHeaders][kRealm]=this[kHeaders][kRealm];const r=new AbortController;return this.signal.aborted?r.abort():this.signal.addEventListener("abort",(function(){r.abort()}),{once:!0}),t[kSignal]=r.signal,t}}function makeRequest(e){const t={method:"GET",localURLsOnly:!1,unsafeRequest:!1,body:null,client:null,reservedClient:null,replacesClientId:"",window:"client",keepalive:!1,serviceWorkers:"all",initiator:"",destination:"",priority:null,origin:"client",policyContainer:"client",referrer:"client",referrerPolicy:"",mode:"no-cors",useCORSPreflightFlag:!1,credentials:"same-origin",useCredentials:!1,cache:"default",redirect:"follow",integrity:"",cryptoGraphicsNonceMetadata:"",parserMetadata:"",reloadNavigation:!1,historyNavigation:!1,userActivation:!1,taintedOrigin:!1,redirectCount:0,responseTainting:"basic",preventNoCacheCacheControlHeaderModification:!1,done:!1,timingAllowFailed:!1,...e,headersList:e.headersList?new HeadersList(...e.headersList):new HeadersList,urlList:e.urlList?[...e.urlList.map((e=>new URL(e)))]:[]};return t.url=t.urlList[0],t}function cloneRequest(e){const t=makeRequest({...e,body:null});return null!==e.body&&(t.body=cloneBody(e.body)),t}mixinBody(Request.prototype),Object.defineProperties(Request.prototype,{method:kEnumerableProperty,url:kEnumerableProperty,headers:kEnumerableProperty,redirect:kEnumerableProperty,clone:kEnumerableProperty,signal:kEnumerableProperty}),module.exports={Request,makeRequest};
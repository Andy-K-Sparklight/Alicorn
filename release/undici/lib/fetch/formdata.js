"use strict";const{isBlobLike,isFileLike,toUSVString}=require("./util"),{kState}=require("./symbols"),{File,FileLike}=require("./file"),{Blob}=require("buffer");class FormData{constructor(...e){if(e.length>0&&"HTMLFormElement"!==e[0]?.constructor?.name)throw new TypeError("Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'");this[kState]=[]}append(...e){if(!(this instanceof FormData))throw new TypeError("Illegal invocation");if(e.length<2)throw new TypeError(`Failed to execute 'append' on 'FormData': 2 arguments required, but only ${e.length} present.`);if(3===e.length&&!isBlobLike(e[1]))throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");const t=toUSVString(e[0]),o=3===e.length?toUSVString(e[2]):void 0,r=makeEntry(t,isBlobLike(e[1])?e[1]:toUSVString(e[1]),o);this[kState].push(r)}delete(...e){if(!(this instanceof FormData))throw new TypeError("Illegal invocation");if(e.length<1)throw new TypeError(`Failed to execute 'delete' on 'FormData': 1 arguments required, but only ${e.length} present.`);const t=toUSVString(e[0]),o=[];for(const e of this[kState])e.name!==t&&o.push(e);this[kState]=o}get(...e){if(!(this instanceof FormData))throw new TypeError("Illegal invocation");if(e.length<1)throw new TypeError(`Failed to execute 'get' on 'FormData': 1 arguments required, but only ${e.length} present.`);const t=toUSVString(e[0]),o=this[kState].findIndex((e=>e.name===t));return-1===o?null:this[kState][o].value}getAll(...e){if(!(this instanceof FormData))throw new TypeError("Illegal invocation");if(e.length<1)throw new TypeError(`Failed to execute 'getAll' on 'FormData': 1 arguments required, but only ${e.length} present.`);const t=toUSVString(e[0]);return this[kState].filter((e=>e.name===t)).map((e=>e.value))}has(...e){if(!(this instanceof FormData))throw new TypeError("Illegal invocation");if(e.length<1)throw new TypeError(`Failed to execute 'has' on 'FormData': 1 arguments required, but only ${e.length} present.`);const t=toUSVString(e[0]);return-1!==this[kState].findIndex((e=>e.name===t))}set(...e){if(!(this instanceof FormData))throw new TypeError("Illegal invocation");if(e.length<2)throw new TypeError(`Failed to execute 'set' on 'FormData': 2 arguments required, but only ${e.length} present.`);if(3===e.length&&!isBlobLike(e[1]))throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");const t=toUSVString(e[0]),o=3===e.length?toUSVString(e[2]):void 0,r=isBlobLike(e[1])?e[1]:toUSVString(e[1]),n=makeEntry(t,r,o),i=this[kState].findIndex((e=>e.name===t));-1!==i?this[kState]=[...this[kState].slice(0,i),n,...this[kState].slice(i+1).filter((e=>e.name!==t))]:this[kState].push(n)}get[Symbol.toStringTag](){if(!(this instanceof FormData))throw new TypeError("Illegal invocation");return this.constructor.name}*entries(){if(!(this instanceof FormData))throw new TypeError("Illegal invocation");for(const e of this)yield e}*keys(){if(!(this instanceof FormData))throw new TypeError("Illegal invocation");for(const[e]of this)yield e}*values(){if(!(this instanceof FormData))throw new TypeError("Illegal invocation");for(const[,e]of this)yield e}*[Symbol.iterator](){for(const{name:e,value:t}of this[kState])yield[e,t]}}function makeEntry(e,t,o){const r={name:null,value:null};return r.name=e,isBlobLike(t)&&!isFileLike(t)&&(t=t instanceof Blob?new File([t],"blob"):new FileLike(t,"blob")),isFileLike(t)&&null!=o&&(t=t instanceof File?new File([t],o):new FileLike(t,o)),r.value=t,r}module.exports={FormData:globalThis.FormData??FormData};
"use strict";const{validateHeaderName,validateHeaderValue}=require("http"),{kHeadersList}=require("../core/symbols"),{kGuard}=require("./symbols"),{kEnumerableProperty}=require("../core/util"),{forbiddenHeaderNames,forbiddenResponseHeaderNames}=require("./constants");function binarySearch(e,r){let t=0,a=Math.floor(e.length/2);for(;a>t;){const i=a+t>>>1;r.localeCompare(e[2*i])>0?t=i+1:a=i}return 2*t}function normalizeAndValidateHeaderName(e){if(void 0===e)throw new TypeError(`Header name ${e}`);const r=e.toLocaleLowerCase();return validateHeaderName(r),r}function normalizeAndValidateHeaderValue(e,r){if(void 0===r)throw new TypeError(r,e);const t=`${r}`.replace(/^[\n\t\r\x20]+|[\n\t\r\x20]+$/g,"");return validateHeaderValue(e,t),t}function fill(e,r){if(r[Symbol.iterator])for(let t of r){if(!t[Symbol.iterator])throw new TypeError;if("string"==typeof t)throw new TypeError;if(Array.isArray(t)||(t=[...t]),2!==t.length)throw new TypeError;e.append(t[0],t[1])}else{if(!r||"object"!=typeof r)throw TypeError();for(const t of Object.entries(r))e.append(t[0],t[1])}}class HeadersList extends Array{append(e,r){const t=normalizeAndValidateHeaderName(e),a=normalizeAndValidateHeaderValue(e,r),i=binarySearch(this,t);this[i]===t?this[i+1]+=`, ${a}`:this.splice(i,0,t,a)}delete(e){const r=normalizeAndValidateHeaderName(e),t=binarySearch(this,r);this[t]===r&&this.splice(t,2)}get(e){const r=normalizeAndValidateHeaderName(e),t=binarySearch(this,r);return this[t]===r?this[t+1]:null}has(e){const r=normalizeAndValidateHeaderName(e);return this[binarySearch(this,r)]===r}set(e,r){const t=normalizeAndValidateHeaderName(e),a=normalizeAndValidateHeaderValue(e,r),i=binarySearch(this,t);this[i]===t?this[i+1]=a:this.splice(i,0,t,a)}}class Headers{constructor(...e){if(void 0!==e[0]&&("object"!=typeof e[0]||null==e[0])&&!Array.isArray(e[0]))throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(record<ByteString, ByteString> or sequence<sequence<ByteString>>");const r=e.length>=1?e[0]??{}:{};this[kHeadersList]=new HeadersList,this[kGuard]="none",fill(this,r)}get[Symbol.toStringTag](){if(!(this instanceof Headers))throw new TypeError("Illegal invocation");return this.constructor.name}toString(){if(!(this instanceof Headers))throw new TypeError("Illegal invocation");return Object.prototype.toString.call(this)}append(...e){if(!(this instanceof Headers))throw new TypeError("Illegal invocation");if(e.length<2)throw new TypeError(`Failed to execute 'append' on 'Headers': 2 arguments required, but only ${e.length} present.`);const r=normalizeAndValidateHeaderName(String(e[0]));if("immutable"===this[kGuard])throw new TypeError("immutable");if("request"!==this[kGuard]||!forbiddenHeaderNames.includes(r)){if("request-no-cors"===this[kGuard]);else if("response"===this[kGuard]&&forbiddenResponseHeaderNames.includes(r))return;return this[kHeadersList].append(String(e[0]),String(e[1]))}}delete(...e){if(!(this instanceof Headers))throw new TypeError("Illegal invocation");if(e.length<1)throw new TypeError(`Failed to execute 'delete' on 'Headers': 1 argument required, but only ${e.length} present.`);const r=normalizeAndValidateHeaderName(String(e[0]));if("immutable"===this[kGuard])throw new TypeError("immutable");if("request"!==this[kGuard]||!forbiddenHeaderNames.includes(r)){if("request-no-cors"===this[kGuard]);else if("response"===this[kGuard]&&forbiddenResponseHeaderNames.includes(r))return;return this[kHeadersList].delete(String(e[0]))}}get(...e){if(!(this instanceof Headers))throw new TypeError("Illegal invocation");if(e.length<1)throw new TypeError(`Failed to execute 'get' on 'Headers': 1 argument required, but only ${e.length} present.`);return this[kHeadersList].get(String(e[0]))}has(...e){if(!(this instanceof Headers))throw new TypeError("Illegal invocation");if(e.length<1)throw new TypeError(`Failed to execute 'has' on 'Headers': 1 argument required, but only ${e.length} present.`);return this[kHeadersList].has(String(e[0]))}set(...e){if(!(this instanceof Headers))throw new TypeError("Illegal invocation");if(e.length<2)throw new TypeError(`Failed to execute 'set' on 'Headers': 2 arguments required, but only ${e.length} present.`);const r=normalizeAndValidateHeaderName(String(e[0]));if("immutable"===this[kGuard])throw new TypeError("immutable");if("request"!==this[kGuard]||!forbiddenHeaderNames.includes(r)){if("request-no-cors"===this[kGuard]);else if("response"===this[kGuard]&&forbiddenResponseHeaderNames.includes(r))return;return this[kHeadersList].set(String(e[0]),String(e[1]))}}*keys(){const e=this[kHeadersList].slice();for(let r=0;r<e.length;r+=2)yield e[r]}*values(){const e=this[kHeadersList].slice();for(let r=1;r<e.length;r+=2)yield e[r]}*entries(){const e=this[kHeadersList].slice();for(let r=0;r<e.length;r+=2)yield[e[r],e[r+1]]}forEach(...e){if(!(this instanceof Headers))throw new TypeError("Illegal invocation");if(e.length<1)throw new TypeError(`Failed to execute 'forEach' on 'Headers': 1 argument required, but only ${e.length} present.`);if("function"!=typeof e[0])throw new TypeError("Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.");const r=e[0],t=e[1];for(let e=0;e<this[kHeadersList].length;e+=2)r.call(t,this[kHeadersList][e+1],this[kHeadersList][e],this)}[Symbol.for("nodejs.util.inspect.custom")](){if(!(this instanceof Headers))throw new TypeError("Illegal invocation");return this[kHeadersList]}}Headers.prototype[Symbol.iterator]=Headers.prototype.entries,Object.defineProperties(Headers.prototype,{append:kEnumerableProperty,delete:kEnumerableProperty,get:kEnumerableProperty,has:kEnumerableProperty,set:kEnumerableProperty,keys:kEnumerableProperty,values:kEnumerableProperty,entries:kEnumerableProperty,forEach:kEnumerableProperty}),module.exports={fill,Headers,HeadersList,binarySearch,normalizeAndValidateHeaderName,normalizeAndValidateHeaderValue};
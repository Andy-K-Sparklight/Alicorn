"use strict";const{Response,makeNetworkError,filterResponse,makeResponse}=require("./response"),{Headers}=require("./headers"),{Request,makeRequest}=require("./request"),zlib=require("zlib"),{ServiceWorkerGlobalScope,Window,matchRequestIntegrity,makePolicyContainer,clonePolicyContainer,requestBadPort,TAOCheck,appendRequestOriginHeader,responseLocationURL,requestCurrentURL,setRequestReferrerPolicyOnRedirect,tryUpgradeRequestToAPotentiallyTrustworthyURL,makeTimingInfo,appendFetchMetadata,corsCheck,crossOriginResourcePolicyCheck,determineRequestsReferrer,coarsenedSharedCurrentTime}=require("./util"),{kState,kHeaders,kGuard,kRealm}=require("./symbols"),{AbortError}=require("../core/errors"),assert=require("assert"),{safelyExtractBody,cancelBody}=require("./body"),{redirectStatus,nullBodyStatus,safeMethods,requestBodyHeader,subresource}=require("./constants"),{kHeadersList}=require("../core/symbols"),EE=require("events"),{PassThrough,pipeline,compose}=require("stream");let ReadableStream;const registry=new FinalizationRegistry((e=>{e()}));async function fetch(...e){if(e.length<1)throw new TypeError(`Failed to execute 'fetch' on 'Window': 1 argument required, but only ${e.length} present.`);if(e.length>=1&&"object"!=typeof e[1]&&void 0!==e[1])throw new TypeError("Failed to execute 'fetch' on 'Window': cannot convert to dictionary.");const r=e[0],t=e.length>=1?e[1]??{}:{},o=Object.assign(new EE,{dispatcher:this,terminated:!1,connection:null,dump:!1,terminate({reason:e,aborted:r}={}){this.terminated||(this.connection&&(this.connection.destroy(),this.connection=null),this.terminated={aborted:r},this.emit("terminated",e))}}),n=createDeferredPromise(),s=new Request(r,t),i=s[kState];if(s.signal.aborted)return abortFetch.call(o,n,i,null),n.promise;const a=i.client?.globalObject;a instanceof ServiceWorkerGlobalScope&&(i.serviceWorkers="none");let c=null,d=!1;return s.signal.addEventListener("abort",(()=>{d=!0,abortFetch.call(o,n,i,c),o.terminate({aborted:!0})}),{once:!0}),fetching.call(o,{request:i,processResponseDone:e=>finalizeAndReportTiming(e,"fetch"),processResponse:e=>{d||(e.aborted?abortFetch.call(o,n,i,c):"error"!==e.type?(c=new Response,c[kState]=e,c[kRealm]=null,c[kHeaders][kHeadersList]=e.headersList,c[kHeaders][kGuard]="immutable",c[kHeaders][kRealm]=null,n.resolve(c)):n.reject(Object.assign(new TypeError("fetch failed"),{cause:e.error})))}}).catch((e=>{n.reject(e)})),n.promise}function finalizeAndReportTiming(e,r="other"){if(!e.urlList?.length)return;const t=e.urlList[0];let o=e.timingInfo,n=e.cacheState;null!==o&&(o.timingAllowPassed||(o=makeTimingInfo({startTime:o.startTime,postRedirectStartTime:o.postRedirectStartTime}),n=""),e.timingInfo.endTime=coarsenedSharedCurrentTime(),e.timingInfo=o,markResourceTiming(o,t,r,global,n))}function markResourceTiming(){}function abortFetch(e,r,t){const o=new AbortError;e.reject(o),null!==r.body&&cancelBody(r.body,o),null!=t&&null!=t[kState].body&&this.connection.destroy(o)}function fetching({request:e,processResponse:r,processResponseDone:t}){let o=null,n=!1;null!==e.client&&(o=e.client.globalObject,n=e.client.crossOriginIsolatedCapability);const s=coarsenedSharedCurrentTime(n),i={request:e,timingInfo:makeTimingInfo({startTime:s,postRedirectStartTime:s}),processRequestBody:null,processRequestEndOfBody:null,processResponse:r,processResponseEndOfBody:null,processResponseDone:t,taskDestination:o,crossOriginIsolatedCapability:n};if(assert(!e.body||e.body.stream),"client"===e.window&&(e.window=e.client?.globalObject instanceof Window?e.client:"no-window"),"client"===e.origin&&(e.origin=e.client?.origin),"client"===e.policyContainer&&(null!==e.client?e.policyContainer=clonePolicyContainer(e.client.policyContainer):e.policyContainer=makePolicyContainer()),!e.headersList.has("accept")){const r="*/*";e.headersList.append("accept",r),e.headersList.has("accept-language")||e.headersList.append("accept-language","*")}return e.priority,subresource.includes(e.destination),mainFetch.call(this,i)}async function mainFetch(e,r=!1){const t=e.request;let o=null;if(t.localURLsOnly&&!/^(about|blob|data):/.test(requestCurrentURL(t).protocol))return makeNetworkError("local URLs only");if(tryUpgradeRequestToAPotentiallyTrustworthyURL(t),"blocked"===requestBadPort(t))return makeNetworkError("bad port");if(""===t.referrerPolicy&&(t.referrerPolicy=t.policyContainer.referrerPolicy),"no-referrer"!==t.referrer&&(t.referrer=determineRequestsReferrer(t)),null===o&&(o=await(async()=>{if("same-origin"===t.mode)return makeNetworkError('request mode cannot be "same-origin"');if("no-cors"===t.mode){if("follow"!==t.redirect)return makeNetworkError('redirect cmode cannot be "follow" for "no-cors" request');t.responseTainting="opaque"}return/^https?:/.test(requestCurrentURL(t).protocol)?(t.responseTainting="cors",await httpFetch.call(this,e).catch((e=>makeNetworkError(e)))):makeNetworkError("URL scheme must be a HTTP(S) scheme")})()),r)return o;0===o.status||o.internalResponse||(t.responseTainting,"basic"===t.responseTainting?o=filterResponse(o,"basic"):"cors"===t.responseTainting?o=filterResponse(o,"cors"):"opaque"===t.responseTainting?o=filterResponse(o,"opaque"):assert(!1));let n=0===o.status?o:o.internalResponse;if(0===n.urlList.length&&n.urlList.push(...t.urlList),t.timingAllowFailed||(o.timingAllowPassed=!0),"opaque"===o.type&&206===n.status&&n.rangeRequested&&!t.headers.has("range")&&(o=n=makeNetworkError()),0===o.status||"HEAD"!==t.method&&"CONNECT"!==t.method&&!nullBodyStatus.includes(n.status)||(n.body=null,this.connection.dump=!0),t.integrity){const r=r=>fetchFinale(e,makeNetworkError(r));if("opaque"===t.responseTainting&&0===o.status)return void r(o.error);const n=n=>{matchRequestIntegrity(t,n)?(o.body=safelyExtractBody(n)[0],fetchFinale(e,o)):r("integrity mismatch")};try{n(await o.arrayBuffer())}catch(e){r(e)}}else fetchFinale(e,o)}function finalizeResponse(e,r){e.request.done=!0,null!==e.processResponseDone&&e.processResponseDone(r)}function fetchFinale(e,r){null!==e.processResponse&&e.processResponse(r),"error"===r.type&&this.terminate({reason:r.error})}async function httpFetch(e){const r=e.request;let t=null,o=null;const n=e.timingInfo;if(r.serviceWorkers,null===t){if("follow"===r.redirect&&(r.serviceWorkers="none"),o=t=await httpNetworkOrCacheFetch.call(this,e),"cors"===r.responseTainting&&"failure"===corsCheck(r,t))return makeNetworkError("cors failure");"failure"===TAOCheck(r,t)&&(r.timingAllowFailed=!0)}return"opaque"!==r.responseTainting&&"opaque"!==t.type||"blocked"!==crossOriginResourcePolicyCheck(r.origin,r.client,r.destination,o)?(redirectStatus.includes(o.status)&&(this.connection.destroy(),"error"===r.redirect?t=makeNetworkError():"manual"===r.redirect?t=filterResponse(o,"opaqueredirect"):"follow"===r.redirect?t=await httpRedirectFetch.call(this,e,t):assert(!1)),t.timingInfo=n,t):makeNetworkError("blocked")}async function httpRedirectFetch(e,r){const t=e.request,o=r.internalResponse?r.internalResponse:r;let n;try{if(n=responseLocationURL(o,requestCurrentURL(t).hash),null==n)return r}catch(e){return makeNetworkError(e)}if(!/^https?:/.test(n.protocol))return makeNetworkError("URL scheme must be a HTTP(S) scheme");if(20===t.redirectCount)return makeNetworkError("redirect count exceeded");if(t.redirectCount+=1,"cors"===t.mode&&(n.username||n.password)&&t.origin!==n.origin)return makeNetworkError('cross origin not allowed for request mode "cors"');if("cors"===t.responseTainting&&(n.username||n.password))return makeNetworkError('URL cannot contain credentials for request mode "cors"');if(303!==o.status&&null!==t.body&&null==t.body.source)return makeNetworkError();if(n.origin!==requestCurrentURL(t).origin&&t.origin!==n.origin&&(t.taintedOrigin=!0),[301,302].includes(o.status)&&"POST"===t.method||303===o.status&&!["GET","HEADER"].includes(t.method)){t.method="GET",t.body=null;for(const e of requestBodyHeader)t.headersList.delete(e)}null!==t.body&&(assert(t.body.source),t.body=safelyExtractBody(t.body.source)[0]);const s=e.timingInfo;return s.redirectEndTime=s.postRedirectStartTime=coarsenedSharedCurrentTime(e.crossOriginIsolatedCapability),0===s.redirectStartTime&&(s.redirectStartTime=s.startTime),t.urlList.push(n),setRequestReferrerPolicyOnRedirect(t,o),mainFetch.call(this,e,!0)}async function httpNetworkOrCacheFetch(e,r=!1,t=!1){const o=this,n=e.request;let s=null,i=null,a=null;"no-window"===n.window&&"error"===n.redirect?(s=e,i=n):(i=makeRequest(n),s={...e},s.request=i);const c="include"===n.credentials||"same-origin"===n.credentials&&"basic"===n.responseTainting,d=i.body?i.body.length:null;let l=null;if(null==i.body&&["POST","PUT"].includes(i.method)&&(l="0"),null!==d&&(l=String(d)),null!==l&&i.headersList.append("content-length",l),null!==d&&i.keepalive,i.referrer instanceof URL&&i.headersList.append("referer",i.referrer.href),appendRequestOriginHeader(i),appendFetchMetadata(i),i.headersList.has("user-agent")||i.headersList.append("user-agent","undici"),"default"===i.cache&&(i.headersList.has("if-modified-since")||i.headersList.has("if-none-match")||i.headersList.has("if-unmodified-since")||i.headersList.has("if-match")||i.headersList.has("if-range"))&&(i.cache="no-store"),"no-cache"!==i.cache||i.preventNoCacheCacheControlHeaderModification||i.headersList.has("cache-control")||i.headersList.append("cache-control","max-age=0"),"no-store"!==i.cache&&"reload"!==i.cache||(i.headersList.has("pragma")||i.headersList.append("pragma","no-cache"),i.headersList.has("cache-control")||i.headersList.append("cache-control","no-cache")),i.headersList.has("range")&&i.headersList.append("accept-encoding","identity"),i.headersList.has("accept-encoding")||(/^https:/.test(requestCurrentURL(i).protocol)?i.headersList.append("accept-encoding","br, gzip, deflate"):i.headersList.append("accept-encoding","gzip, deflate")),i.cache="no-store","no-store"!==i.mode&&i.mode,null==a){if("only-if-cached"===i.mode)return makeNetworkError("only if cached");const e=await httpNetworkFetch.call(this,s,c,t);!safeMethods.includes(i.method)&&e.status>=200&&e.status,null==a&&(a=e)}if(a.urlList=[...i.urlList],i.headersList.has("range")&&(a.rangeRequested=!0),407===a.status)return"no-window"===n.window?makeNetworkError():o.terminated?makeNetworkError(o.terminated.aborted?new AbortError:null):makeNetworkError("proxy authentication required");if(421===a.status&&!t&&(null==n.body||null!==n.body.source)){if(o.terminated){const e=o.terminated.aborted?new AbortError:new Error("terminated");return makeNetworkError(e)}o.connection.destroy(),a=await httpNetworkOrCacheFetch.call(this,e,r,!0)}return a}function httpNetworkFetch(e,r=!1,t=!1){const o=this;return new Promise((r=>{assert(!o.connection||o.connection.destroyed);const t=o.connection={abort:null,controller:null,destroyed:!1,errored:!1,dump:!1,destroy(e){if(!this.destroyed&&(this.destroyed=!0,this.abort&&(this.abort(),this.abort=null),e&&(this.errored=e),this.controller))try{this.controller.error(e??new AbortError),this.controller=null}catch(e){if("TypeError"!==e.name)throw e}}},n=e.request;let s=null;const i=e.timingInfo;n.cache="no-store",n.mode,o.on("terminated",c);const a=async function*(){try{if(null===n.body)return void e.processEndOfBody?.();for await(const r of n.body.stream){if(o.terminated)return;yield r,e.processRequestBody?.(r.byteLength)}if(o.terminated)return;e.processRequestEndOfBody?.()}catch(e){if(o.terminated)return;o.terminate({aborted:"AbortError"===e.name,reason:e})}}();function c(){const e=o.terminated.aborted;t.destroy();const n=e?new AbortError:new Error("terminated");r(makeNetworkError(n))}let d;ReadableStream||(ReadableStream=require("stream/web").ReadableStream);const l=new ReadableStream({async start(e){t.controller=e},async pull(){d?d():d=null},async cancel(e){o.terminate({aborted:!0})}},{highWaterMark:65536});function u(){finalizeResponse(e,s),o.terminated.aborted?(s.aborted=!0,t.destroy(new AbortError)):t.destroy(new TypeError("terminated")),t.destroy()}const h=requestCurrentURL(n);o.dispatcher.dispatch({path:h.pathname+h.search,origin:h.origin,method:n.method,body:a,headers:n.headersList,maxRedirections:0},{decoder:null,onConnect(e){t.destroyed?e(new AbortError):t.abort=e},onHeaders(n,a,h,m){if(n<200)return;const p=new Headers;for(let e=0;e<a.length;e+=2)p.append(a[e+0].toString(),a[e+1].toString());const f=void 0!==d,y={stream:l};registry.register(y,t.abort),s=makeResponse({status:n,statusText:m,headersList:p[kHeadersList],body:y}),o.on("terminated",u);const g=p.get("content-encoding")?.toLowerCase().split(",").map((e=>e.trim()))??[],b=[];for(const e of g)if(/(x-)?gzip/.test(e))b.push(zlib.createGunzip());else if(/(x-)?deflate/.test(e))b.push(zlib.createInflate());else{if("br"!==e){b.length=0;break}b.push(zlib.createBrotliDecompress())}let k;return b.length>1?compose?(this.decoder=compose(...b),k=this.decoder[Symbol.asyncIterator]()):(this.decoder=new PassThrough,k=pipeline(this.decoder,...b,(()=>{}))[Symbol.asyncIterator]()):1===b.length?(this.decoder=b[0],k=this.decoder[Symbol.asyncIterator]()):(this.decoder=new PassThrough,k=this.decoder[Symbol.asyncIterator]()),this.decoder&&this.decoder.on("drain",h),d=async()=>{let r;try{const{done:e,value:t}=await k.next();r=e?void 0:t}catch(e){r=this.decoder.writableEnded&&!i.encodedBodySize?void 0:e}if(t.controller){if(void 0===r)return finalizeResponse(e,s),o.off("terminated",u),o.off("terminated",c),t.controller.close(),t.controller=null,void t.destroy();if(i.decodedBodySize+=r?.byteLength??0,r instanceof Error)o.terminate({reason:r});else{if(t.controller.enqueue(new Uint8Array(r)),!t.errored)return t.controller.desiredSize>0;o.terminate({reason:t.errored})}}},f&&d(),r(s),!0},onData(e){if(t.dump)return;const r=e;return i.encodedBodySize+=r.byteLength,this.decoder.write(r)},async onComplete(){this.decoder.end()},onError(e){o.off("terminated",u),o.off("terminated",c),t.destroy(e),o.terminate({reason:e}),s||r(makeNetworkError(e))}})}))}function createDeferredPromise(){let e,r;return{promise:new Promise(((t,o)=>{e=t,r=o})),resolve:e,reject:r}}module.exports=fetch;
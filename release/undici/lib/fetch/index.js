"use strict";const{Response,makeNetworkError,filterResponse,makeResponse}=require("./response"),{Headers}=require("./headers"),{Request,makeRequest}=require("./request"),zlib=require("zlib"),{ServiceWorkerGlobalScope,Window,matchRequestIntegrity,makePolicyContainer,clonePolicyContainer,requestBadPort,TAOCheck,appendRequestOriginHeader,responseLocationURL,requestCurrentURL,setRequestReferrerPolicyOnRedirect,tryUpgradeRequestToAPotentiallyTrustworthyURL,makeTimingInfo,appendFetchMetadata,corsCheck,crossOriginResourcePolicyCheck,determineRequestsReferrer,coarsenedSharedCurrentTime}=require("./util"),{kState,kHeaders,kGuard,kRealm,kError}=require("./symbols"),{AbortError}=require("../core/errors"),assert=require("assert"),{safelyExtractBody,cancelBody}=require("./body"),{redirectStatus,nullBodyStatus,safeMethods,requestBodyHeader,subresource}=require("./constants"),{kHeadersList}=require("../core/symbols"),EE=require("events"),{PassThrough,pipeline,compose}=require("stream");let ReadableStream;const registry=new FinalizationRegistry((e=>{e()}));async function fetch(...e){if(e.length<1)throw new TypeError(`Failed to execute 'fetch' on 'Window': 1 argument required, but only ${e.length} present.`);if(e.length>=1&&"object"!=typeof e[1]&&void 0!==e[1])throw new TypeError("Failed to execute 'fetch' on 'Window': cannot convert to dictionary.");const r=e[0],t=e.length>=1?e[1]??{}:{},o=Object.assign(new EE,{dispatcher:this,terminated:!1,connection:null,dump:!1,terminate({reason:e,aborted:r}={}){this.terminated||(this.terminated={aborted:r},this.connection&&(this.connection.destroy(e),this.connection=null),this.emit("terminated",e))}}),n=createDeferredPromise(),s=new Request(r,t),i=s[kState];if(s.signal.aborted)return abortFetch.call(o,n,i,null),n.promise;const a=i.client?.globalObject;a instanceof ServiceWorkerGlobalScope&&(i.serviceWorkers="none");let c=null,d=!1;return s.signal.addEventListener("abort",(()=>{d=!0,abortFetch.call(o,n,i,c),o.terminate({aborted:!0})}),{once:!0}),fetching.call(o,{request:i,processResponseDone:e=>finalizeAndReportTiming(e,"fetch"),processResponse:e=>{d||(e.aborted?abortFetch.call(o,n,i,c):"error"!==e.type?(c=new Response,c[kState]=e,c[kRealm]=null,c[kHeaders][kHeadersList]=e.headersList,c[kHeaders][kGuard]="immutable",c[kHeaders][kRealm]=null,n.resolve(c)):n.reject(Object.assign(new TypeError("fetch failed"),{cause:e.error})))}}).catch((e=>{n.reject(e)})),n.promise}function finalizeAndReportTiming(e,r="other"){if(!e.urlList?.length)return;const t=e.urlList[0];let o=e.timingInfo,n=e.cacheState;null!==o&&(o.timingAllowPassed||(o=makeTimingInfo({startTime:o.startTime,postRedirectStartTime:o.postRedirectStartTime}),n=""),e.timingInfo.endTime=coarsenedSharedCurrentTime(),e.timingInfo=o,markResourceTiming(o,t,r,global,n))}function markResourceTiming(){}function abortFetch(e,r,t){const o=new AbortError;if(e.reject(o),null!=r.body&&cancelBody(r.body,o),null==t)return;const n=t[kState];null!=n.body&&cancelBody(n.body,o)}function fetching({request:e,processResponse:r,processResponseDone:t}){let o=null,n=!1;null!=e.client&&(o=e.client.globalObject,n=e.client.crossOriginIsolatedCapability);const s=coarsenedSharedCurrentTime(n),i={request:e,timingInfo:makeTimingInfo({startTime:s,postRedirectStartTime:s}),processRequestBody:null,processRequestEndOfBody:null,processResponse:r,processResponseEndOfBody:null,processResponseDone:t,taskDestination:o,crossOriginIsolatedCapability:n};if(assert(!e.body||e.body.stream),"client"===e.window&&(e.window=e.client?.globalObject instanceof Window?e.client:"no-window"),"client"===e.origin&&(e.origin=e.client?.origin),"client"===e.policyContainer&&(null!=e.client?e.policyContainer=clonePolicyContainer(e.client.policyContainer):e.policyContainer=makePolicyContainer()),!e.headersList.has("accept")){const r="*/*";e.headersList.append("accept",r),e.headersList.has("accept-language")||e.headersList.append("accept-language","*")}return e.priority,subresource.includes(e.destination),mainFetch.call(this,i)}async function mainFetch(e,r=!1){const t=e.request;let o=null;if(t.localURLsOnly&&!/^(about|blob|data):/.test(requestCurrentURL(t).protocol))return makeNetworkError("local URLs only");if(tryUpgradeRequestToAPotentiallyTrustworthyURL(t),"blocked"===requestBadPort(t))return makeNetworkError("bad port");if(""===t.referrerPolicy&&(t.referrerPolicy=t.policyContainer.referrerPolicy),"no-referrer"!==t.referrer&&(t.referrer=determineRequestsReferrer(t)),null===o&&(o=await(async()=>{if("same-origin"===t.mode)return makeNetworkError('request mode cannot be "same-origin"');if("no-cors"===t.mode){if("follow"!==t.redirect)return makeNetworkError('redirect cmode cannot be "follow" for "no-cors" request');t.responseTainting="opaque"}return/^https?:/.test(requestCurrentURL(t).protocol)?(t.responseTainting="cors",await httpFetch.call(this,e).catch((e=>makeNetworkError(e)))):makeNetworkError("URL scheme must be a HTTP(S) scheme")})()),r)return o;0===o.status||o.internalResponse||(t.responseTainting,"basic"===t.responseTainting?o=filterResponse(o,"basic"):"cors"===t.responseTainting?o=filterResponse(o,"cors"):"opaque"===t.responseTainting?o=filterResponse(o,"opaque"):assert(!1));let n=0===o.status?o:o.internalResponse;if(0===n.urlList.length&&n.urlList.push(...t.urlList),t.timingAllowFailed||(o.timingAllowPassed=!0),"opaque"===o.type&&206===n.status&&n.rangeRequested&&!t.headers.has("range")&&(o=n=makeNetworkError()),0===o.status||"HEAD"!==t.method&&"CONNECT"!==t.method&&!nullBodyStatus.includes(n.status)||(n.body=null,this.dump=!0),t.integrity){const r=r=>fetchFinale(e,makeNetworkError(r));if("opaque"===t.responseTainting&&0===o.status)return void r(o.error);const n=n=>{matchRequestIntegrity(t,n)?(o.body=safelyExtractBody(n)[0],fetchFinale(e,o)):r("integrity mismatch")};try{n(await o.arrayBuffer())}catch(e){r(e)}}else fetchFinale(e,o)}function finalizeResponse(e,r){e.request.done=!0,null!=e.processResponseDone&&e.processResponseDone(r)}function fetchFinale(e,r){null!=e.processResponse&&e.processResponse(r),"error"===r.type&&this.terminate({reason:r.error})}async function httpFetch(e){const r=e.request;let t=null,o=null;const n=e.timingInfo;if(r.serviceWorkers,null===t){if("follow"===r.redirect&&(r.serviceWorkers="none"),o=t=await httpNetworkOrCacheFetch.call(this,e),"cors"===r.responseTainting&&"failure"===corsCheck(r,t))return makeNetworkError("cors failure");"failure"===TAOCheck(r,t)&&(r.timingAllowFailed=!0)}return"opaque"!==r.responseTainting&&"opaque"!==t.type||"blocked"!==crossOriginResourcePolicyCheck(r.origin,r.client,r.destination,o)?(redirectStatus.includes(o.status)&&(this.connection.destroy(),"error"===r.redirect?t=makeNetworkError():"manual"===r.redirect?t=filterResponse(o,"opaqueredirect"):"follow"===r.redirect?t=await httpRedirectFetch.call(this,e,t):assert(!1)),t.timingInfo=n,t):makeNetworkError("blocked")}async function httpRedirectFetch(e,r){const t=e.request,o=r.internalResponse?r.internalResponse:r;let n;try{if(n=responseLocationURL(o,requestCurrentURL(t).hash),null==n)return r}catch(e){return makeNetworkError(e)}if(!/^https?:/.test(n.protocol))return makeNetworkError("URL scheme must be a HTTP(S) scheme");if(20===t.redirectCount)return makeNetworkError("redirect count exceeded");if(t.redirectCount+=1,"cors"===t.mode&&(n.username||n.password)&&t.origin!==n.origin)return makeNetworkError('cross origin not allowed for request mode "cors"');if("cors"===t.responseTainting&&(n.username||n.password))return makeNetworkError('URL cannot contain credentials for request mode "cors"');if(303!==o.status&&null!=t.body&&null==t.body.source)return makeNetworkError();if(n.origin!==requestCurrentURL(t).origin&&t.origin!==n.origin&&(t.taintedOrigin=!0),[301,302].includes(o.status)&&"POST"===t.method||303===o.status&&!["GET","HEADER"].includes(t.method)){t.method="GET",t.body=null;for(const e of requestBodyHeader)t.headersList.delete(e)}null!=t.body&&(assert(t.body.source),t.body=safelyExtractBody(t.body.source)[0]);const s=e.timingInfo;return s.redirectEndTime=s.postRedirectStartTime=coarsenedSharedCurrentTime(e.crossOriginIsolatedCapability),0===s.redirectStartTime&&(s.redirectStartTime=s.startTime),t.urlList.push(n),setRequestReferrerPolicyOnRedirect(t,o),mainFetch.call(this,e,!0)}async function httpNetworkOrCacheFetch(e,r=!1,t=!1){const o=this,n=e.request;let s=null,i=null,a=null;"no-window"===n.window&&"error"===n.redirect?(s=e,i=n):(i=makeRequest(n),s={...e},s.request=i);const c="include"===n.credentials||"same-origin"===n.credentials&&"basic"===n.responseTainting,d=i.body?i.body.length:null;let l=null;if(null==i.body&&["POST","PUT"].includes(i.method)&&(l="0"),null!=d&&(l=String(d)),null!=l&&i.headersList.append("content-length",l),null!=d&&i.keepalive,i.referrer instanceof URL&&i.headersList.append("referer",i.referrer.href),appendRequestOriginHeader(i),appendFetchMetadata(i),i.headersList.has("user-agent")||i.headersList.append("user-agent","undici"),"default"===i.cache&&(i.headersList.has("if-modified-since")||i.headersList.has("if-none-match")||i.headersList.has("if-unmodified-since")||i.headersList.has("if-match")||i.headersList.has("if-range"))&&(i.cache="no-store"),"no-cache"!==i.cache||i.preventNoCacheCacheControlHeaderModification||i.headersList.has("cache-control")||i.headersList.append("cache-control","max-age=0"),"no-store"!==i.cache&&"reload"!==i.cache||(i.headersList.has("pragma")||i.headersList.append("pragma","no-cache"),i.headersList.has("cache-control")||i.headersList.append("cache-control","no-cache")),i.headersList.has("range")&&i.headersList.append("accept-encoding","identity"),i.headersList.has("accept-encoding")||(/^https:/.test(requestCurrentURL(i).protocol)?i.headersList.append("accept-encoding","br, gzip, deflate"):i.headersList.append("accept-encoding","gzip, deflate")),i.cache="no-store","no-store"!==i.mode&&i.mode,null==a){if("only-if-cached"===i.mode)return makeNetworkError("only if cached");const e=await httpNetworkFetch.call(this,s,c,t);!safeMethods.includes(i.method)&&e.status>=200&&e.status,null==a&&(a=e)}if(a.urlList=[...i.urlList],i.headersList.has("range")&&(a.rangeRequested=!0),407===a.status)return"no-window"===n.window?makeNetworkError():o.terminated?makeNetworkError(o.terminated.aborted?new AbortError:null):makeNetworkError("proxy authentication required");if(421===a.status&&!t&&(null==n.body||null!=n.body.source)){if(o.terminated){const e=o.terminated.aborted?new AbortError:new Error("terminated");return makeNetworkError(e)}o.connection.destroy(),a=await httpNetworkOrCacheFetch.call(this,e,r,!0)}return a}function httpNetworkFetch(e,r=!1,t=!1){const o=this;return new Promise((r=>{assert(!o.connection||o.connection.destroyed),o.connection={abort:null,destroyed:!1,destroy(e){this.destroyed||(this.destroyed=!0,this.abort?.(e??new AbortError))}};const t=e.request;let n=null;const s=e.timingInfo;t.cache="no-store",t.mode,o.on("terminated",(function(){const e=this.terminated.aborted;this.connection?.destroy();const t=e?new AbortError:new Error("terminated");r(makeNetworkError(t))}));const i=async function*(){try{if(null===t.body)return void e.processEndOfBody?.();for await(const r of t.body.stream){if(o.terminated)return;yield r,e.processRequestBody?.(r.byteLength)}if(o.terminated)return;e.processRequestEndOfBody?.()}catch(e){if(o.terminated)return;o.terminate({aborted:"AbortError"===e.name,reason:e})}}();let a,c;ReadableStream||(ReadableStream=require("stream/web").ReadableStream);const d=new ReadableStream({async start(e){o.controller=e},async pull(e){a||await new Promise((e=>{c=e})),await a(e)},async cancel(e){d[kError]=e,await void o.terminate({aborted:!0})}},{highWaterMark:65536});function l(){if(finalizeResponse(e,n),this.terminated.aborted){n.aborted=!0;try{this.controller.error(new AbortError)}catch(e){if("TypeError"!==e.name)throw e}}else try{this.controller.error(new TypeError("terminated"))}catch(e){if("TypeError"!==e.name)throw e}this.connection?.destroy()}const u=requestCurrentURL(t);o.dispatcher.dispatch({path:u.pathname+u.search,origin:u.origin,method:t.method,body:i,headers:t.headersList,maxRedirections:0},{decoder:null,abort:null,context:o,onConnect(e){const{connection:r}=this.context;r.destroyed?e(new AbortError):this.abort=r.abort=e},onHeaders(t,o,i,u){if(t<200)return;const h=new Headers;for(let e=0;e<o.length;e+=2)h.append(o[e+0].toString(),o[e+1].toString());registry.register(d,this.abort,this),n=makeResponse({status:t,statusText:u,headersList:h[kHeadersList],body:{stream:d}}),this.context.on("terminated",l);const p=h.get("content-encoding")?.toLowerCase().split(",").map((e=>e.trim()))??[],m=[];for(const e of p)if(/(x-)?gzip/.test(e))m.push(zlib.createGunzip());else if(/(x-)?deflate/.test(e))m.push(zlib.createInflate());else{if("br"!==e){m.length=0;break}m.push(zlib.createBrotliDecompress())}let f;return m.length>1?compose?(this.decoder=compose(...m),f=this.decoder[Symbol.asyncIterator]()):(this.decoder=new PassThrough,f=pipeline(this.decoder,...m,(()=>{}))[Symbol.asyncIterator]()):1===m.length?(this.decoder=m[0],f=this.decoder[Symbol.asyncIterator]()):(this.decoder=new PassThrough,f=this.decoder[Symbol.asyncIterator]()),this.decoder&&this.decoder.on("drain",i),a=async r=>{let t;try{const{done:e,value:r}=await f.next();t=e?void 0:r}catch(e){t=this.decoder.writableEnded&&!s.encodedBodySize?void 0:e}if(void 0===t)return finalizeResponse(e,n),void r.close();if(s.decodedBodySize+=t?.byteLength??0,t instanceof Error)this.context.terminate({reason:t});else{if(r.enqueue(new Uint8Array(t)),!d[kError])return r.desiredSize>0;this.context.terminate({reason:d[kError]})}},c&&(c(),c=null),r(n),!0},onData(e){if(this.context.dump)return;const r=e;return s.encodedBodySize+=r.byteLength,this.decoder.write(r)},onComplete(){registry.unregister(this),this.decoder.end()},onError(e){registry.unregister(this),this.decoder?.destroy(e),this.context.terminate({reason:e}),n||r(makeNetworkError(e))}})}))}function createDeferredPromise(){let e,r;return{promise:new Promise(((t,o)=>{e=t,r=o})),resolve:e,reject:r}}module.exports=fetch;
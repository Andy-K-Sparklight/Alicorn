"use strict";const{Blob}=require("buffer"),{kState}=require("./symbols");class File extends Blob{constructor(e,t,i={}){const r=t,o=i.type,l=i.lastModified??Date.now();super(e,{type:o}),this[kState]={name:r,lastModified:l}}get name(){if(!(this instanceof File))throw new TypeError("Illegal invocation");return this[kState].name}get lastModified(){if(!(this instanceof File))throw new TypeError("Illegal invocation");return this[kState].lastModified}[Symbol.toStringTag](){if(!(this instanceof File))throw new TypeError("Illegal invocation");return"File"}}class FileLike{constructor(e,t,i={}){const r=t,o=(i.type,i.lastModified??Date.now());this[kState]={blobLike:e,name:r,lastModified:o}}stream(...e){return this[kState].blobLike.stream(...e)}arrayBuffer(...e){return this[kState].blobLike.arrayBuffer(...e)}slice(...e){return this[kState].blobLike.slice(...e)}text(...e){return this[kState].blobLike.text(...e)}get size(){return this[kState].blobLike.size}get type(){return this[kState].blobLike.type}get name(){if(!(this instanceof FileLike))throw new TypeError("Illegal invocation");return this[kState].name}get lastModified(){if(!(this instanceof FileLike))throw new TypeError("Illegal invocation");return this[kState].lastModified}[Symbol.toStringTag](){if(!(this instanceof FileLike))throw new TypeError("Illegal invocation");return"File"}}module.exports={File:globalThis.File??File,FileLike};
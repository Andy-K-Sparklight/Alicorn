"use strict";const{MockNotMatchedError}=require("./mock-errors"),{kDispatches,kMockAgent,kOriginalDispatch,kOrigin,kIsMockActive,kGetNetConnect}=require("./mock-symbols");function matchValue(e,t){return"string"==typeof e?e===t:e instanceof RegExp?e.test(t):"function"==typeof e&&!0===e(t)}function matchHeaders(e,t){if(void 0===e.headers)return!0;if("object"!=typeof t||"object"!=typeof e.headers)return!1;for(const[o,c]of Object.entries(e.headers))if(!matchValue(c,t[o]))return!1;return!0}function matchKey(e,{path:t,method:o,body:c,headers:n}){const s=matchValue(e.path,t),r=matchValue(e.method,o),a=void 0===e.body||matchValue(e.body,c),i=matchHeaders(e,n);return s&&r&&a&&i}function getResponseData(e){return Buffer.isBuffer(e)?e:"object"==typeof e?JSON.stringify(e):e.toString()}function getMockDispatch(e,t){let o=e.filter((({consumed:e})=>!e)).filter((({path:e})=>matchValue(e,t.path)));if(0===o.length)throw new MockNotMatchedError(`Mock dispatch not matched for path '${t.path}'`);if(o=o.filter((({method:e})=>matchValue(e,t.method))),0===o.length)throw new MockNotMatchedError(`Mock dispatch not matched for method '${t.method}'`);if(o=o.filter((({body:e})=>void 0===e||matchValue(e,t.body))),0===o.length)throw new MockNotMatchedError(`Mock dispatch not matched for body '${t.body}'`);if(o=o.filter((e=>matchHeaders(e,t.headers))),0===o.length)throw new MockNotMatchedError(`Mock dispatch not matched for headers '${"object"==typeof t.headers?JSON.stringify(t.headers):t.headers}'`);return o[0]}function addMockDispatch(e,t,o){const c={times:null,persist:!1,consumed:!1,...t,data:{error:null,...o}};return e.push(c),c}function deleteMockDispatch(e,t){const o=e.findIndex((e=>!!e.consumed&&matchKey(e,t)));-1!==o&&e.splice(o,1)}function buildKey(e){const{path:t,method:o,body:c,headers:n}=e;return{path:t,method:o,body:c,headers:n}}function generateKeyValues(e){return Object.entries(e).reduce(((e,[t,o])=>[...e,t,o]),[])}async function getResponse(e){const t=[];for await(const o of e)t.push(o);return Buffer.concat(t).toString("utf8")}function mockDispatch(e,t){const o=buildKey(e),c=getMockDispatch(this[kDispatches],o),{data:{statusCode:n,data:s,headers:r,trailers:a,error:i},delay:h,persist:d}=c;let{times:u}=c;if("number"==typeof u&&u>0&&(u=--c.times),!0===d||"number"==typeof u&&u>0||(c.consumed=!0),null!==i)return deleteMockDispatch(this[kDispatches],o),t.onError(i),!0;function l(e){const c=getResponseData(s),i=generateKeyValues(r),h=generateKeyValues(a);t.onHeaders(n,i,f),t.onData(Buffer.from(c)),t.onComplete(h),deleteMockDispatch(e,o)}function f(){}return"number"==typeof h&&h>0?setTimeout((()=>{l(this[kDispatches])}),h):l(this[kDispatches]),!0}function buildMockDispatch(){const e=this[kMockAgent],t=this[kOrigin],o=this[kOriginalDispatch];return function(c,n){if(e[kIsMockActive])try{mockDispatch.call(this,c,n)}catch(s){if(!(s instanceof MockNotMatchedError))throw s;{const r=e[kGetNetConnect]();if(!1===r)throw new MockNotMatchedError(`${s.message}: subsequent request to origin ${t} was not allowed (net.connect disabled)`);if(!checkNetConnect(r,t))throw new MockNotMatchedError(`${s.message}: subsequent request to origin ${t} was not allowed (net.connect is not enabled for this origin)`);o.call(this,c,n)}}else o.call(this,c,n)}}function checkNetConnect(e,t){const o=new URL(t);return!0===e||!(!Array.isArray(e)||!e.some((e=>matchValue(e,o.host))))}function buildMockOptions(e){if(e){const{agent:t,...o}=e;return o}}module.exports={getResponseData,getMockDispatch,addMockDispatch,deleteMockDispatch,buildKey,generateKeyValues,matchValue,getResponse,mockDispatch,buildMockDispatch,checkNetConnect,buildMockOptions};
"use strict";const assert=require("assert"),net=require("net"),util=require("./core/util"),Request=require("./core/request"),Dispatcher=require("./dispatcher"),RedirectHandler=require("./handler/redirect"),{RequestContentLengthMismatchError,ResponseContentLengthMismatchError,TrailerMismatchError,InvalidArgumentError,RequestAbortedError,HeadersTimeoutError,HeadersOverflowError,ClientDestroyedError,ClientClosedError,SocketError,InformationalError,BodyTimeoutError,HTTPParserError}=require("./core/errors"),buildConnector=require("./core/connect"),{kUrl,kReset,kServerName,kClient,kBusy,kParser,kConnect,kBlocking,kResuming,kRunning,kPending,kSize,kWriting,kQueue,kConnected,kConnecting,kNeedDrain,kNoRef,kKeepAliveDefaultTimeout,kHostHeader,kClosed,kDestroyed,kPendingIdx,kRunningIdx,kError,kOnDestroyed,kPipelining,kSocket,kKeepAliveTimeoutValue,kMaxHeadersSize,kKeepAliveMaxTimeout,kKeepAliveTimeoutThreshold,kHeadersTimeout,kBodyTimeout,kStrictContentLength,kConnector,kMaxRedirections,kMaxRequests,kCounter}=require("./core/symbols"),channels={};try{const e=require("diagnostics_channel");channels.sendHeaders=e.channel("undici:client:sendHeaders"),channels.beforeConnect=e.channel("undici:client:beforeConnect"),channels.connectError=e.channel("undici:client:connectError"),channels.connected=e.channel("undici:client:connected")}catch{channels.sendHeaders={hasSubscribers:!1},channels.beforeConnect={hasSubscribers:!1},channels.connectError={hasSubscribers:!1},channels.connected={hasSubscribers:!1}}class Client extends Dispatcher{constructor(e,{maxHeaderSize:t,headersTimeout:r,socketTimeout:n,requestTimeout:s,connectTimeout:i,bodyTimeout:o,idleTimeout:u,keepAlive:a,keepAliveTimeout:l,maxKeepAliveTimeout:c,keepAliveMaxTimeout:h,keepAliveTimeoutThreshold:d,socketPath:k,pipelining:m,tls:f,strictContentLength:g,maxCachedSessions:p,maxRedirections:y,connect:R,maxRequestsPerClient:E}={}){if(super(),void 0!==a)throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");if(void 0!==n)throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");if(void 0!==s)throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");if(void 0!==u)throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");if(void 0!==c)throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");if(null!=t&&!Number.isFinite(t))throw new InvalidArgumentError("invalid maxHeaderSize");if(null!=k&&"string"!=typeof k)throw new InvalidArgumentError("invalid socketPath");if(null!=i&&(!Number.isFinite(i)||i<0))throw new InvalidArgumentError("invalid connectTimeout");if(null!=l&&(!Number.isFinite(l)||l<=0))throw new InvalidArgumentError("invalid keepAliveTimeout");if(null!=h&&(!Number.isFinite(h)||h<=0))throw new InvalidArgumentError("invalid keepAliveMaxTimeout");if(null!=d&&!Number.isFinite(d))throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");if(null!=r&&(!Number.isInteger(r)||r<0))throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");if(null!=o&&(!Number.isInteger(o)||o<0))throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");if(null!=R&&"function"!=typeof R&&"object"!=typeof R)throw new InvalidArgumentError("connect must be a function or an object");if(null!=y&&(!Number.isInteger(y)||y<0))throw new InvalidArgumentError("maxRedirections must be a positive number");if(null!=E&&(!Number.isInteger(E)||E<0))throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");"function"!=typeof R&&(R=buildConnector({...f,maxCachedSessions:p,socketPath:k,timeout:i,...R})),this[kUrl]=util.parseOrigin(e),this[kConnector]=R,this[kSocket]=null,this[kPipelining]=null!=m?m:1,this[kMaxHeadersSize]=t||16384,this[kKeepAliveDefaultTimeout]=null==l?4e3:l,this[kKeepAliveMaxTimeout]=null==h?6e5:h,this[kKeepAliveTimeoutThreshold]=null==d?1e3:d,this[kKeepAliveTimeoutValue]=this[kKeepAliveDefaultTimeout],this[kClosed]=!1,this[kDestroyed]=!1,this[kServerName]=null,this[kOnDestroyed]=[],this[kResuming]=0,this[kNeedDrain]=0,this[kHostHeader]=`host: ${this[kUrl].hostname}${this[kUrl].port?`:${this[kUrl].port}`:""}\r\n`,this[kBodyTimeout]=null!=o?o:3e4,this[kHeadersTimeout]=null!=r?r:3e4,this[kStrictContentLength]=null==g||g,this[kMaxRedirections]=y,this[kMaxRequests]=E,this[kQueue]=[],this[kRunningIdx]=0,this[kPendingIdx]=0}get pipelining(){return this[kPipelining]}set pipelining(e){this[kPipelining]=e,resume(this,!0)}get destroyed(){return this[kDestroyed]}get closed(){return this[kClosed]}get[kPending](){return this[kQueue].length-this[kPendingIdx]}get[kRunning](){return this[kPendingIdx]-this[kRunningIdx]}get[kSize](){return this[kQueue].length-this[kRunningIdx]}get[kConnected](){return!!this[kSocket]&&!this[kConnecting]&&!this[kSocket].destroyed}get[kBusy](){const e=this[kSocket];return e&&(e[kReset]||e[kWriting]||e[kBlocking])||this[kSize]>=(this[kPipelining]||1)||this[kPending]>0}[kConnect](e){connect(this),this.once("connect",e)}dispatch(e,t){if(!t||"object"!=typeof t)throw new InvalidArgumentError("handler must be an object");try{if(!e||"object"!=typeof e)throw new InvalidArgumentError("opts must be an object.");if(this[kDestroyed])throw new ClientDestroyedError;if(this[kClosed])throw new ClientClosedError;const{maxRedirections:r=this[kMaxRedirections]}=e;r&&(t=new RedirectHandler(this,r,e,t));const n=e.origin||this[kUrl].origin,s=new Request(n,e,t);this[kQueue].push(s),this[kResuming]||(null==util.bodyLength(s.body)&&util.isIterable(s.body)?(this[kResuming]=1,process.nextTick(resume,this)):resume(this,!0)),this[kResuming]&&2!==this[kNeedDrain]&&this[kBusy]&&(this[kNeedDrain]=2)}catch(e){if("function"!=typeof t.onError)throw new InvalidArgumentError("invalid onError method");t.onError(e)}return this[kNeedDrain]<2}close(e){if(void 0===e)return new Promise(((e,t)=>{this.close(((r,n)=>r?t(r):e(n)))}));if("function"!=typeof e)throw new InvalidArgumentError("invalid callback");this[kDestroyed]?queueMicrotask((()=>e(new ClientDestroyedError,null))):(this[kClosed]=!0,this[kSize]?this[kOnDestroyed].push(e):this.destroy(e))}destroy(e,t){if("function"==typeof e&&(t=e,e=null),void 0===t)return new Promise(((t,r)=>{this.destroy(e,((e,n)=>e?r(e):t(n)))}));if("function"!=typeof t)throw new InvalidArgumentError("invalid callback");if(this[kDestroyed])return void(this[kOnDestroyed]?this[kOnDestroyed].push(t):queueMicrotask((()=>t(null,null))));e||(e=new ClientDestroyedError);const r=this[kQueue].splice(this[kPendingIdx]);for(let t=0;t<r.length;t++)errorRequest(this,r[t],e);this[kClosed]=!0,this[kDestroyed]=!0,this[kOnDestroyed].push(t);const n=()=>{const e=this[kOnDestroyed];this[kOnDestroyed]=null;for(let t=0;t<e.length;t++)e[t](null,null)};this[kSocket]?util.destroy(this[kSocket].on("close",n),e):queueMicrotask(n),resume(this)}}const constants=require("./llhttp/constants"),EMPTY_BUF=Buffer.alloc(0);async function lazyllhttp(){const{resolve:e}=require("path"),{readFile:t}=require("fs").promises;let r;try{r=await WebAssembly.compile(await t(e(__dirname,"./llhttp/llhttp_simd.wasm")))}catch(n){r=await WebAssembly.compile(await t(e(__dirname,"./llhttp/llhttp.wasm")))}return await WebAssembly.instantiate(r,{env:{wasm_on_url:(e,t,r)=>0,wasm_on_status:(e,t,r)=>{assert.strictEqual(currentParser.ptr,e);const n=t-currentBufferPtr,s=n+r;return currentParser.onStatus(currentBufferRef.slice(n,s))||0},wasm_on_message_begin:e=>(assert.strictEqual(currentParser.ptr,e),currentParser.onMessageBegin()||0),wasm_on_header_field:(e,t,r)=>{assert.strictEqual(currentParser.ptr,e);const n=t-currentBufferPtr,s=n+r;return currentParser.onHeaderField(currentBufferRef.slice(n,s))||0},wasm_on_header_value:(e,t,r)=>{assert.strictEqual(currentParser.ptr,e);const n=t-currentBufferPtr,s=n+r;return currentParser.onHeaderValue(currentBufferRef.slice(n,s))||0},wasm_on_headers_complete:(e,t,r,n)=>(assert.strictEqual(currentParser.ptr,e),currentParser.onHeadersComplete(t,Boolean(r),Boolean(n))||0),wasm_on_body:(e,t,r)=>{assert.strictEqual(currentParser.ptr,e);const n=t-currentBufferPtr,s=n+r;return currentParser.onBody(currentBufferRef.slice(n,s))||0},wasm_on_message_complete:e=>(assert.strictEqual(currentParser.ptr,e),currentParser.onMessageComplete()||0)}})}let llhttpInstance=null,llhttpPromise=lazyllhttp().catch((()=>{})),currentParser=null,currentBufferRef=null,currentBufferSize=0,currentBufferPtr=null;const TIMEOUT_HEADERS=1,TIMEOUT_BODY=2,TIMEOUT_IDLE=3;class Parser{constructor(e,t,{exports:r}){assert(Number.isFinite(e[kMaxHeadersSize])&&e[kMaxHeadersSize]>0),this.llhttp=r,this.ptr=this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE),this.client=e,this.socket=t,this.timeout=null,this.timeoutValue=null,this.timeoutType=null,this.statusCode=null,this.statusText="",this.upgrade=!1,this.headers=[],this.headersSize=0,this.headersMaxSize=e[kMaxHeadersSize],this.shouldKeepAlive=!1,this.paused=!1,this.resume=this.resume.bind(this),this.bytesRead=0,this.trailer="",this.keepAlive="",this.contentLength=""}setTimeout(e,t){this.timeoutType=t,e!==this.timeoutValue?(clearTimeout(this.timeout),e?(this.timeout=setTimeout(onParserTimeout,e,this),this.timeout.unref&&this.timeout.unref()):this.timeout=null,this.timeoutValue=e):this.timeout&&this.timeout.refresh&&this.timeout.refresh()}resume(){!this.socket.destroyed&&this.paused&&(assert(null!=this.ptr),assert(null==currentParser),this.llhttp.llhttp_resume(this.ptr),assert(2===this.timeoutType),this.timeout&&this.timeout.refresh&&this.timeout.refresh(),this.paused=!1,this.execute(this.socket.read()||EMPTY_BUF),this.readMore())}readMore(){for(;!this.paused&&this.ptr;){const e=this.socket.read();if(null===e)break;this.execute(e)}}execute(e){assert(null!=this.ptr),assert(null==currentParser),assert(!this.paused);const{socket:t,llhttp:r}=this;e.length>currentBufferSize&&(currentBufferPtr&&r.free(currentBufferPtr),currentBufferSize=4096*Math.ceil(e.length/4096),currentBufferPtr=r.malloc(currentBufferSize)),new Uint8Array(r.memory.buffer,currentBufferPtr,currentBufferSize).set(e);try{let n;try{currentBufferRef=e,currentParser=this,n=r.llhttp_execute(this.ptr,currentBufferPtr,e.length)}catch(e){throw e}finally{currentParser=null,currentBufferRef=null}const s=r.llhttp_get_error_pos(this.ptr)-currentBufferPtr;if(n===constants.ERROR.PAUSED_UPGRADE)this.onUpgrade(e.slice(s));else if(n===constants.ERROR.PAUSED)this.paused=!0,t.unshift(e.slice(s));else if(n!==constants.ERROR.OK){const t=r.llhttp_get_error_reason(this.ptr);let i="";if(t){const e=new Uint8Array(r.memory.buffer,t).indexOf(0);i=Buffer.from(r.memory.buffer,t,e).toString()}throw new HTTPParserError(i,constants.ERROR[n],e.slice(s))}}catch(e){util.destroy(t,e)}}finish(){try{try{currentParser=this,this.llhttp.llhttp_finish(this.ptr)}finally{currentParser=null}}catch(e){util.destroy(this.socket,e)}}destroy(){assert(null!=this.ptr),assert(null==currentParser),this.llhttp.llhttp_free(this.ptr),this.ptr=null,clearTimeout(this.timeout),this.timeout=null,this.timeoutValue=null,this.timeoutType=null,this.paused=!1}onStatus(e){this.statusText=e.toString()}onMessageBegin(){const{socket:e,client:t}=this;return e.destroyed?-1:t[kQueue][t[kRunningIdx]]?void 0:-1}onHeaderField(e){const t=this.headers.length;0==(1&t)?this.headers.push(e):this.headers[t-1]=Buffer.concat([this.headers[t-1],e]),this.trackHeader(e.length)}onHeaderValue(e){let t=this.headers.length;1==(1&t)?(this.headers.push(e),t+=1):this.headers[t-1]=Buffer.concat([this.headers[t-1],e]);const r=this.headers[t-2];10===r.length&&"keep-alive"===r.toString().toLowerCase()?this.keepAlive+=e.toString():7===r.length&&"trailer"===r.toString().toLowerCase()?this.trailer+=e.toString():14===r.length&&"content-length"===r.toString().toLowerCase()&&(this.contentLength+=e.toString()),this.trackHeader(e.length)}trackHeader(e){this.headersSize+=e,this.headersSize>=this.headersMaxSize&&util.destroy(this.socket,new HeadersOverflowError)}onUpgrade(e){const{upgrade:t,client:r,socket:n,headers:s,statusCode:i}=this;assert(t);const o=r[kQueue][r[kRunningIdx]];assert(o),assert(!n.destroyed),assert(n===r[kSocket]),assert(!this.paused),assert(o.upgrade||"CONNECT"===o.method),this.statusCode=null,this.statusText="",this.shouldKeepAlive=null,assert(this.headers.length%2==0),this.headers=[],this.headersSize=0,n.unshift(e),n[kParser].destroy(),n[kParser]=null,n[kClient]=null,n[kError]=null,n.removeListener("error",onSocketError).removeListener("readable",onSocketReadable).removeListener("end",onSocketEnd).removeListener("close",onSocketClose),r[kSocket]=null,r[kQueue][r[kRunningIdx]++]=null,r.emit("disconnect",r[kUrl],[r],new InformationalError("upgrade"));try{o.onUpgrade(i,s,n)}catch(e){util.destroy(n,e)}resume(r)}onHeadersComplete(e,t,r){const{client:n,socket:s,headers:i,statusText:o}=this;if(s.destroyed)return-1;const u=n[kQueue][n[kRunningIdx]];if(!u)return-1;if(assert(!this.upgrade),assert(this.statusCode<200),100===e)return util.destroy(s,new SocketError("bad response",util.getSocketInfo(s))),-1;if(t&&!u.upgrade)return util.destroy(s,new SocketError("bad upgrade",util.getSocketInfo(s))),-1;if(assert.strictEqual(this.timeoutType,1),this.statusCode=e,this.shouldKeepAlive=r,this.statusCode>=200){const e=null!=u.bodyTimeout?u.bodyTimeout:n[kBodyTimeout];this.setTimeout(e,2)}else this.timeout&&this.timeout.refresh&&this.timeout.refresh();if("CONNECT"===u.method&&e>=200&&e<300)return assert(1===n[kRunning]),this.upgrade=!0,2;if(t)return assert(1===n[kRunning]),this.upgrade=!0,2;if(assert(this.headers.length%2==0),this.headers=[],this.headersSize=0,r&&n[kPipelining]){const e=this.keepAlive?util.parseKeepAliveTimeout(this.keepAlive):null;if(null!=e){const t=Math.min(e-n[kKeepAliveTimeoutThreshold],n[kKeepAliveMaxTimeout]);t<=0?s[kReset]=!0:n[kKeepAliveTimeoutValue]=t}else n[kKeepAliveTimeoutValue]=n[kKeepAliveDefaultTimeout]}else s[kReset]=!0;let a;try{a=!1===u.onHeaders(e,i,this.resume,o)}catch(e){return util.destroy(s,e),-1}return"HEAD"===u.method?(assert(s[kReset]),1):e<200?1:(s[kBlocking]&&(s[kBlocking]=!1,resume(n)),a?constants.ERROR.PAUSED:0)}onBody(e){const{client:t,socket:r,statusCode:n}=this;if(r.destroyed)return-1;const s=t[kQueue][t[kRunningIdx]];assert(s),assert.strictEqual(this.timeoutType,2),this.timeout&&this.timeout.refresh&&this.timeout.refresh(),assert(n>=200),this.bytesRead+=e.length;try{if(!1===s.onData(e))return constants.ERROR.PAUSED}catch(e){return util.destroy(r,e),-1}}onMessageComplete(){const{client:e,socket:t,statusCode:r,upgrade:n,trailer:s,headers:i,contentLength:o,bytesRead:u,shouldKeepAlive:a}=this;if(t.destroyed&&(!r||a))return-1;if(n)return;const l=e[kQueue][e[kRunningIdx]];if(assert(l),assert(r>=100),this.statusCode=null,this.statusText="",this.bytesRead=0,this.contentLength="",this.trailer="",this.keepAlive="",assert(this.headers.length%2==0),this.headers=[],this.headersSize=0,r<200)return;const c=s?s.split(/,\s*/):[];for(let e=0;e<c.length;e++){const r=c[e];let n=!1;for(let e=0;e<i.length;e+=2){const t=i[e];if(t.length===r.length&&t.toString().toLowerCase()===r.toLowerCase()){n=!0;break}}if(!n)return util.destroy(t,new TrailerMismatchError),-1}if("HEAD"!==l.method&&o&&u!==parseInt(o,10))return util.destroy(t,new ResponseContentLengthMismatchError),-1;try{l.onComplete(i)}catch(t){errorRequest(e,l,t)}return e[kQueue][e[kRunningIdx]++]=null,t[kWriting]?(assert.strictEqual(e[kRunning],0),util.destroy(t,new InformationalError("reset")),constants.ERROR.PAUSED):a?t[kReset]&&0===e[kRunning]?(util.destroy(t,new InformationalError("reset")),constants.ERROR.PAUSED):void resume(e):(util.destroy(t,new InformationalError("reset")),constants.ERROR.PAUSED)}}function onParserTimeout(e){const{socket:t,timeoutType:r,client:n}=e;1===r?t[kWriting]||(assert(!e.paused,"cannot be paused while waiting for headers"),util.destroy(t,new HeadersTimeoutError)):2===r?e.paused||util.destroy(t,new BodyTimeoutError):3===r&&(assert(0===n[kRunning]&&n[kKeepAliveTimeoutValue]),util.destroy(t,new InformationalError("socket idle timeout")))}function onSocketReadable(e){const{[kParser]:t}=this;t.readMore()}function onSocketError(e){const{[kParser]:t}=this;assert("ERR_TLS_CERT_ALTNAME_INVALID"!==e.code),"ECONNRESET"!==e.code||!t.statusCode||t.shouldKeepAlive?(this[kError]=e,onError(this[kClient],e)):t.finish()}function onError(e,t){if(0===e[kRunning]&&"UND_ERR_INFO"!==t.code&&"UND_ERR_SOCKET"!==t.code){assert(e[kPendingIdx]===e[kRunningIdx]);const r=e[kQueue].splice(e[kRunningIdx]);for(let n=0;n<r.length;n++)errorRequest(e,r[n],t);assert(0===e[kSize])}}function onSocketEnd(){const{[kParser]:e}=this;!e.statusCode||e.shouldKeepAlive?util.destroy(this,new SocketError("other side closed",util.getSocketInfo(this))):e.finish()}function onSocketClose(){const{[kClient]:e}=this;this[kParser].destroy(),this[kParser]=null;const t=this[kError]||new SocketError("closed",util.getSocketInfo(this));if(e[kSocket]=null,e[kDestroyed]){assert(0===e[kPending]);const r=e[kQueue].splice(e[kRunningIdx]);for(let n=0;n<r.length;n++)errorRequest(e,r[n],t)}else if(e[kRunning]>0&&"UND_ERR_INFO"!==t.code){const r=e[kQueue][e[kRunningIdx]];e[kQueue][e[kRunningIdx]++]=null,errorRequest(e,r,t)}e[kPendingIdx]=e[kRunningIdx],assert(0===e[kRunning]),e.emit("disconnect",e[kUrl],[e],t),resume(e)}async function connect(e){assert(!e[kConnecting]),assert(!e[kSocket]);let{host:t,hostname:r,protocol:n,port:s}=e[kUrl];if("["===r[0]){const e=r.indexOf("]");assert(-1!==e);const t=r.substr(1,e-1);assert(net.isIP(t)),r=t}e[kConnecting]=!0,channels.beforeConnect.hasSubscribers&&channels.beforeConnect.publish({connectParams:{host:t,hostname:r,protocol:n,port:s,servername:e[kServerName]},connector:e[kConnector]});try{const i=await new Promise(((i,o)=>{e[kConnector]({host:t,hostname:r,protocol:n,port:s,servername:e[kServerName]},((e,t)=>{e?o(e):i(t)}))}));llhttpInstance||(llhttpInstance=await llhttpPromise,llhttpPromise=null),e[kConnecting]=!1,assert(i),e[kSocket]=i,i[kNoRef]=!1,i[kWriting]=!1,i[kReset]=!1,i[kBlocking]=!1,i[kError]=null,i[kParser]=new Parser(e,i,llhttpInstance),i[kClient]=e,i[kCounter]=0,i[kMaxRequests]=e[kMaxRequests],i.on("error",onSocketError).on("readable",onSocketReadable).on("end",onSocketEnd).on("close",onSocketClose),channels.connected.hasSubscribers&&channels.connected.publish({connectParams:{host:t,hostname:r,protocol:n,port:s,servername:e[kServerName]},connector:e[kConnector],socket:i}),e.emit("connect",e[kUrl],[e])}catch(i){if(e[kConnecting]=!1,channels.connectError.hasSubscribers&&channels.connectError.publish({connectParams:{host:t,hostname:r,protocol:n,port:s,servername:e[kServerName]},connector:e[kConnector],error:i}),"ERR_TLS_CERT_ALTNAME_INVALID"===i.code)for(assert(0===e[kRunning]);e[kPending]>0&&e[kQueue][e[kPendingIdx]].servername===e[kServerName];){const t=e[kQueue][e[kPendingIdx]++];errorRequest(e,t,i)}else onError(e,i);e.emit("connectionError",e[kUrl],[e],i)}resume(e)}function emitDrain(e){e[kNeedDrain]=0,e.emit("drain",e[kUrl],[e])}function resume(e,t){2!==e[kResuming]&&(e[kResuming]=2,_resume(e,t),e[kResuming]=0,e[kRunningIdx]>256&&(e[kQueue].splice(0,e[kRunningIdx]),e[kPendingIdx]-=e[kRunningIdx],e[kRunningIdx]=0))}function _resume(e,t){for(;;){if(e[kDestroyed])return void assert(0===e[kPending]);if(e[kClosed]&&!e[kSize]){e.destroy(util.nop);continue}const r=e[kSocket];if(r)if(0===e[kSize]?!r[kNoRef]&&r.unref&&(r.unref(),r[kNoRef]=!0):r[kNoRef]&&r.ref&&(r.ref(),r[kNoRef]=!1),0===e[kSize])3!==r[kParser].timeoutType&&r[kParser].setTimeout(e[kKeepAliveTimeoutValue],3);else if(e[kRunning]>0&&r[kParser].statusCode<200&&1!==r[kParser].timeoutType){const t=e[kQueue][e[kRunningIdx]],n=null!=t.headersTimeout?t.headersTimeout:e[kHeadersTimeout];r[kParser].setTimeout(n,1)}if(e[kBusy])e[kNeedDrain]=2;else if(2===e[kNeedDrain]){t?(e[kNeedDrain]=1,process.nextTick(emitDrain,e)):emitDrain(e);continue}if(0===e[kPending])return;if(e[kRunning]>=(e[kPipelining]||1))return;const n=e[kQueue][e[kPendingIdx]];if("https:"===e[kUrl].protocol&&e[kServerName]!==n.servername){if(e[kRunning]>0)return;if(e[kServerName]=n.servername,r&&r.servername!==n.servername)return void util.destroy(r,new InformationalError("servername changed"))}if(e[kConnecting])return;if(r){if(r.destroyed||r[kWriting]||r[kReset]||r[kBlocking])return;if(e[kRunning]>0&&!n.idempotent)return;if(e[kRunning]>0&&(n.upgrade||"CONNECT"===n.method))return;if(util.isStream(n.body)&&0===util.bodyLength(n.body)&&(n.body.on("data",(function(){assert(!1)})).on("error",(function(t){errorRequest(e,n,t)})).on("end",(function(){util.destroy(this)})),n.body=null),e[kRunning]>0&&(util.isStream(n.body)||util.isAsyncIterable(n.body)))return;!n.aborted&&write(e,n)?e[kPendingIdx]++:e[kQueue].splice(e[kPendingIdx],1)}else connect(e)}}function write(e,t){const{body:r,method:n,path:s,host:i,upgrade:o,headers:u,blocking:a}=t,l="PUT"===n||"POST"===n||"PATCH"===n;r&&"function"==typeof r.read&&r.read(0);let c=util.bodyLength(r);if(null===c&&(c=t.contentLength),0!==c||l||(c=null),null!==t.contentLength&&t.contentLength!==c){if(e[kStrictContentLength])return errorRequest(e,t,new RequestContentLengthMismatchError),!1;process.emitWarning(new RequestContentLengthMismatchError)}const h=e[kSocket];try{t.onConnect((r=>{t.aborted||t.completed||(errorRequest(e,t,r||new RequestAbortedError),util.destroy(h,new InformationalError("aborted")))}))}catch(r){errorRequest(e,t,r)}if(t.aborted)return!1;"HEAD"===n&&(h[kReset]=!0),(o||"CONNECT"===n)&&(h[kReset]=!0),e[kMaxRequests]&&h[kCounter]++>=e[kMaxRequests]&&(h[kReset]=!0),a&&(h[kBlocking]=!0);let d=`${n} ${s} HTTP/1.1\r\n`;return d+=i?`host: ${i}\r\n`:e[kHostHeader],o?d+=`connection: upgrade\r\nupgrade: ${o}\r\n`:e[kPipelining]?d+="connection: keep-alive\r\n":d+="connection: close\r\n",u&&(d+=u),channels.sendHeaders.hasSubscribers&&channels.sendHeaders.publish({request:t,headers:d,socket:h}),r?util.isBuffer(r)?(assert(c===r.byteLength,"buffer body must have content length"),h.cork(),h.write(`${d}content-length: ${c}\r\n\r\n`,"ascii"),h.write(r),h.uncork(),t.onBodySent(r),t.onRequestSent(),l||(h[kReset]=!0)):util.isBlobLike(r)?"function"==typeof r.stream?writeIterable({body:r.stream(),client:e,request:t,socket:h,contentLength:c,header:d,expectsPayload:l}):writeBlob({body:r,client:e,request:t,socket:h,contentLength:c,header:d,expectsPayload:l}):util.isStream(r)?writeStream({body:r,client:e,request:t,socket:h,contentLength:c,header:d,expectsPayload:l}):util.isIterable(r)?writeIterable({body:r,client:e,request:t,socket:h,contentLength:c,header:d,expectsPayload:l}):assert(!1):(0===c?h.write(`${d}content-length: 0\r\n\r\n`,"ascii"):(assert(null===c,"no body must not have content length"),h.write(`${d}\r\n`,"ascii")),t.onRequestSent()),!0}function writeStream({body:e,client:t,request:r,socket:n,contentLength:s,header:i,expectsPayload:o}){assert(0!==s||0===t[kRunning],"stream body cannot be pipelined");let u=!1;const a=new AsyncWriter({socket:n,request:r,contentLength:s,client:t,expectsPayload:o,header:i}),l=function(e){try{assert(!u),!a.write(e)&&this.pause&&this.pause()}catch(e){util.destroy(this,e)}},c=function(){assert(!u),e.resume&&e.resume()},h=function(){d(new RequestAbortedError)},d=function(r){if(!u){if(u=!0,assert(n.destroyed||n[kWriting]&&t[kRunning]<=1),n.off("drain",c).off("error",d),e.removeListener("data",l).removeListener("end",d).removeListener("error",d).removeListener("close",h),!r)try{a.end()}catch(e){r=e}a.destroy(r),!r||"UND_ERR_INFO"===r.code&&"reset"===r.message?util.destroy(e):util.destroy(e,r)}};e.on("data",l).on("end",d).on("error",d).on("close",h),e.resume&&e.resume(),n.on("drain",c).on("error",d)}async function writeBlob({body:e,client:t,request:r,socket:n,contentLength:s,header:i,expectsPayload:o}){assert(s===e.size,"blob body must have content length");try{if(null!=s&&s!==e.size)throw new RequestContentLengthMismatchError;const u=Buffer.from(await e.arrayBuffer());n.cork(),n.write(`${i}content-length: ${s}\r\n\r\n`,"ascii"),n.write(u),n.uncork(),r.onBodySent(u),r.onRequestSent(),o||(n[kReset]=!0),resume(t)}catch(e){util.destroy(n,e)}}async function writeIterable({body:e,client:t,request:r,socket:n,contentLength:s,header:i,expectsPayload:o}){assert(0!==s||0===t[kRunning],"iterator body cannot be pipelined");let u=null;function a(){if(u){const e=u;u=null,e()}}n.on("close",a).on("drain",a);const l=new AsyncWriter({socket:n,request:r,contentLength:s,client:t,expectsPayload:o,header:i});try{for await(const t of e){if(n[kError])throw n[kError];l.write(t)||await new Promise(((e,t)=>{assert(null===u),n[kError]?t(n[kError]):u=e}))}l.end()}catch(e){l.destroy(e)}finally{n.off("close",a).off("drain",a)}}class AsyncWriter{constructor({socket:e,request:t,contentLength:r,client:n,expectsPayload:s,header:i}){this.socket=e,this.request=t,this.contentLength=r,this.client=n,this.bytesWritten=0,this.expectsPayload=s,this.header=i,e[kWriting]=!0}write(e){const{socket:t,request:r,contentLength:n,client:s,bytesWritten:i,expectsPayload:o,header:u}=this;if(t[kError])throw t[kError];if(t.destroyed)return!1;const a=Buffer.byteLength(e);if(!a)return!0;if(null!==n&&i+a>n){if(s[kStrictContentLength])throw new RequestContentLengthMismatchError;process.emitWarning(new RequestContentLengthMismatchError)}0===i&&(o||(t[kReset]=!0),null===n?t.write(`${u}transfer-encoding: chunked\r\n`,"ascii"):t.write(`${u}content-length: ${n}\r\n\r\n`,"ascii")),null===n&&t.write(`\r\n${a.toString(16)}\r\n`,"ascii"),this.bytesWritten+=a;const l=t.write(e);return r.onBodySent(e),l}end(){const{socket:e,contentLength:t,client:r,bytesWritten:n,expectsPayload:s,header:i,request:o}=this;if(o.onRequestSent(),e[kWriting]=!1,e[kError])throw e[kError];if(!e.destroyed){if(0===n?s?e.write(`${i}content-length: 0\r\n\r\n`,"ascii"):e.write(`${i}\r\n`,"ascii"):null===t&&e.write("\r\n0\r\n\r\n","ascii"),null!==t&&n!==t){if(r[kStrictContentLength])throw new RequestContentLengthMismatchError;process.emitWarning(new RequestContentLengthMismatchError)}e[kParser].timeout&&1===e[kParser].timeoutType&&e[kParser].timeout.refresh&&e[kParser].timeout.refresh(),resume(r)}}destroy(e){const{socket:t,client:r}=this;t[kWriting]=!1,e&&(assert(r[kRunning]<=1,"pipeline should only contain this request"),util.destroy(t,e))}}function errorRequest(e,t,r){try{t.onError(r),assert(t.aborted)}catch(r){e.emit("error",r)}}module.exports=Client;